#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Launcher1_Loader, sensorPotentiometer)
#pragma config(Sensor, in2,    Launcher2_Loader, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  Launcher1_Ready, sensorTouch)
#pragma config(Sensor, dgtl2,  Launcher1_BallLoaded, sensorTouch)
#pragma config(Sensor, dgtl3,  Launcher2_Ready, sensorTouch)
#pragma config(Sensor, dgtl4,  Launcher2_BallLoaded, sensorTouch)
#pragma config(Sensor, I2C_1,  Wheels_I2C,     sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           Loader1,       tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           Launcher1_H,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           Launcher1_M,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           Launcher1_L,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           Wheels_Front,  tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           Wheels_Back,   tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port7,           Launcher2_H,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           Launcher2_M,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Launcher2_L,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          Loader2,       tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

enum LauncherMode{
	Left = 0,
	Right = 1,
};

task LaunchBall();
task LaunchBall_Right();
task LauncherUp();
task LauncherStop();
task LauncherDown_Left();
task LauncherDown_Right();
task RotateLoader();
task CloseLoader();
task CloseLoader_Right();
task OpenLoader();
task OpenLoader_Right();
//task LaunchBall_ProgrammingSKills();

bool Launcher_Loaded;

void LaunchBall_ProgrammingSKills();
void LauncherDown_Left_Helper(int count);
void LauncherDown_Right_Helper(int count);
void LauncherStop_Helper();
void OpenLoader_Helper();
void OpenLoader_Right_Helper();
void CloseLoader_Helper();
void CloseLoader_Right_Helper();
void TravelToTheOtherSide_Straight();
void ForBackHelper(int power);
void StopMoving();
void EncoderRotate(int power, int distance);
void RotateHelper(int power);
void MoveToTheGoal();

//void ShiftHelper(30);

int AdjustPowerUsingBatteryLevel(int originalPower)
{
	float batteryLevel = nImmediateBatteryLevel;
	float batteryOffset =	7000 / batteryLevel;
	int adjustedPower = originalPower * batteryOffset;
	//  writeDebugStreamLine("(AjustBattery) BatterLevel: %d - OriginalPower: %d - WantedPower: %d", AdjustBatteryLevel, OriginalPower, WantedPower);
	return adjustedPower;
}


//int AdjustPowerUsingExternalBatteryLevel(int originalPower)
//{
//	float batteryLevel = SensorValue[ExternalBatteryValue] * 3.57;

//	float batteryOffset =	7000 / batteryLevel;
//	int adjustedPower = originalPower * batteryOffset;
//	//  writeDebugStreamLine("(AjustBattery) BatterLevel: %d - OriginalPower: %d - WantedPower: %d", AdjustBatteryLevel, OriginalPower, WantedPower);
//	return adjustedPower;
//}


void EncoderForBack(int power, int distance)
{
	nMotorEncoder(Wheels_Back) = 0;
	////
	//if (power <= 0) return;

	int current = abs(nMotorEncoder(Wheels_Back));
	float offset = 0;

	// RED only for programming skill
	// power = -power;
	while (current + offset < distance)
	{
		int previous = current;

		ForBackHelper(power);
		//motor[FrontLeft] = power;
		//motor[FrontRight] = power;
		//motor[BackRight] = power;
		//motor[BackLeft] = power;

		int current = abs(nMotorEncoder(Wheels_Back));

		offset = current - previous;
		offset = offset * 1.6;
	}

	StopMoving();
}

void ForBackHelper(int power)
{
	int adjustedPower = AdjustPowerUsingBatteryLevel(power);

	motor[Wheels_Front] = adjustedPower;
	motor[Wheels_Back] = -adjustedPower;//* 90 / 100;

	//motor[FrontLeft] = -adjustedPower;
	//motor[FrontRight] = adjustedPower;
	//motor[BackLeft] = adjustedPower;
	//motor[BackRight] = -adjustedPower;
}

void StopMoving()
{
	motor[Wheels_Front] = 0;
	motor[Wheels_Back] = 0;
}

void TravelToTheOtherSide_Straight()
{
	int originalPower = 125;
	int power = AdjustPowerUsingBatteryLevel(originalPower);

	EncoderForBack(power, 3750);
	wait1Msec(500);

	originalPower = 40;
	power = AdjustPowerUsingBatteryLevel(originalPower);

	ForBackHelper(power);
	wait1Msec(900);
	StopMoving();

	ForBackHelper(-power);
	wait1Msec(250);
	StopMoving();

	////wait1Msec(100);
	////nMotorEncoder(FrontLeft) = 0;
	////EncoderForBack(30, 100);


	//nMotorEncoder(FrontLeft) = 0;
	//EncoderRotate(60, 250);

	//wait1Msec(100);
	////nMotorEncoder(FrontLeft) = 0;
	////EncoderForBack(-100, 1900);
	//ForBackHelper(30);
	//wait1Msec(350);
	////wait1Msec(100);

	//nMotorEncoder(FrontLeft) = 0;
	//EncoderForBack(-100, 2400);

	//ForBackHelper(-30);
	//wait1Msec(800);

	//StopMoving();

	//nMotorEncoder(FrontLeft) = 0;
	//EncoderRotate(-60, 50);

}

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{

		int btn5u = vexRT[Btn5U]; // Fast Launcher
		int btn5d = vexRT[Btn5D]; // Fast Launcher

		int btn6u = vexRT[Btn6U]; // Fast Launcher
		int btn6d = vexRT[Btn6D]; // Fast Launcher

		int btn7u = vexRT[Btn7U]; // Fast Launcher
		int btn7d = vexRT[Btn7D]; // Slow Launcher
		int btn7l = vexRT[Btn7L]; // shift
		int btn7r = vexRT[Btn7R]; // shift

		//int btn8u = vexRT[Btn8U]; // Fast Launcher
		int btn8d = vexRT[Btn8D]; // Slow Launcher
		int btn8l = vexRT[Btn8L]; // Slow Launcher
		int btn8r = vexRT[Btn8R]; // Slow Launcher

		int power4 = vexRT[Ch4]; // forward, backward
		int power1 = vexRT[Ch1]; // rotate

		//standard drive motor block
		motor[Wheels_Front] = power4 + power1;
		motor[Wheels_Back] = -power4 + power1;//* 90 / 100;
		//motor[BackRight] = power4 + power1;// * 90 / 100;
		//motor[BackLeft] = -power4 - power1;// * 90 / 100;

		//int power8 = 100; // shift

		//int powerLauncher = 90; // shift
		//int powerLoader = 12;

		////motor[Loader1] = -btn8d * powerLoader;
		//motor[Launcher1_H] = -btn8u * powerLauncher;
		//motor[Launcher1_M] = -btn8u * powerLauncher;
		//motor[Launcher1_L] = -btn8u * powerLauncher;


		//int powerWall = 70;
		//motor[Loader1] = -btn8d * powerLoader;
		//motor[Launcher1_Wall] = -btn7u * powerWall + btn7d * powerWall;


		//int powerBelt = 70;
		//motor[Belt] = -btn6u * powerBelt + btn6d * powerBelt;

		if (btn8r == 1)
		{
			startTask(CloseLoader_Right);

		}
		else if (btn8d == 1)
		{
			//EncoderForBack(-80, 100);
			startTask(LauncherDown_Right);
		}
		else if (btn8l == 1)
		{
			//EncoderForBack(-80, 100);
			startTask(LaunchBall_Right);
		}
		else if (btn6u == 1)
		{
			TravelToTheOtherSide_Straight();
		}
		else if (btn6d == 1)
		{
			MoveToTheGoal();
		}

		else if (btn5u == 1)
		{
			//startTask(LaunchBall_ProgrammingSKills);
			LaunchBall_ProgrammingSKills();
		}
		else if (btn5d == 1)
		{
			stopTask(LauncherDown_Left);
			stopTask(LauncherDown_Right);
			stopTask(LaunchBall);
			stopTask(LaunchBall_Right);
			stopTask(RotateLoader);


			//wait1Msec(10);
			startTask(LauncherStop);
			CloseLoader_Helper();
			CloseLoader_Right_Helper();
			StopMoving();

			motor[Loader1] = 0;
			motor[Loader2] = 0;
		}
		else if (btn7d == 1)
		{
			//stopTask(LauncherUp);

			//wait1Msec(10);
			startTask(LauncherDown_Left);
		}
		else if (btn7l == 1)
		{
			//stopTask(LauncherUp);

			//wait1Msec(10);
			startTask(LaunchBall);
		}
		else if (btn7r == 1)
		{
			//stopTask(LauncherUp);

			//wait1Msec(10);
			//startTask(RotateLoader);
			startTask(CloseLoader);
			//startTask(OpenLoader);

		}
	}
}


//task LaunchBall_ProgrammingSKills()
void LaunchBall_ProgrammingSKills()
{
	int ballCounts = 3;
	long startTime = nPgmTime;

	LauncherDown_Left_Helper(ballCounts);

	writeDebugStreamLine("LaunchBall) Right Elapsed Time: %d", nPgmTime - startTime);
	startTask(LauncherStop);

	motor[Loader1] = 0;
	motor[Loader2] = 0;
	//wait1Msec(1000);

	//int power = 50;
	//ForBackHelper(-power);
	//wait1Msec(300);
	//StopMoving();

	wait1Msec(1000);

	TravelToTheOtherSide_Straight();
	writeDebugStreamLine("LaunchBall) Moved-1 Elapsed Time: %d", nPgmTime - startTime);

	wait1Msec(1000);

	LauncherDown_Right_Helper(ballCounts);

	writeDebugStreamLine("LaunchBall) Left Elapsed Time: %d", nPgmTime - startTime);

	motor[Loader1] = 0;
	motor[Loader2] = 0;

	startTask(LauncherStop);

	wait1Msec(1000);

	MoveToTheGoal();
	writeDebugStreamLine("LaunchBall) Moved-2 Elapsed Time: %d", nPgmTime - startTime);
}

void MoveToTheGoal()
{

	nMotorEncoder(Wheels_Back) = 0;
	int power = 50;
	EncoderRotate(power, 420);
	wait1Msec(500);

	int originalPower = 70;
	power = AdjustPowerUsingBatteryLevel(originalPower);

	ForBackHelper(power);
	wait1Msec(1000);
	StopMoving();
	wait1Msec(1000);

	//originalPower = 90;
	//power = AdjustPowerUsingBatteryLevel(originalPower);

	ForBackHelper(power);
	wait1Msec(1000);
	StopMoving();
	wait1Msec(500);

	ForBackHelper(-power);
	wait1Msec(300);
	StopMoving();

	//nMotorEncoder(Wheels_Back) = 0;
	//power = 50;
	//EncoderRotate(power, 30);
	//wait1Msec(500);

	ForBackHelper(power);
	wait1Msec(500);

	motor[Wheels_Back] = 0;
	wait1Msec(1000);
	StopMoving();


	ForBackHelper(-power);
	wait1Msec(300);
	StopMoving();

	//nMotorEncoder(Wheels_Back) = 0;
	//power = 50;
	//EncoderRotate(power, 30);
	//wait1Msec(500);

	ForBackHelper(70);
	wait1Msec(1000);

}

void EncoderRotate(int power, int distance)
{
	int current = abs(nMotorEncoder(Wheels_Back));
	float offset = 0;

	if (power == 0) return;

	//power = -power;
	while (current + offset < distance)
	{
		int previous = current;

		RotateHelper(power);

		int current = abs(nMotorEncoder(Wheels_Back));

		offset = current - previous;
		offset = offset * 1.6;
	}

	StopMoving();
}

void RotateHelper(int power)
{
	int adjustedPower = AdjustPowerUsingBatteryLevel(power);

	motor[Wheels_Front] = -adjustedPower;
	motor[Wheels_Back] = -adjustedPower;
}


task LaunchBall()
{//
	long startTime = nPgmTime;

	LauncherDown_Left_Helper(32);

	writeDebugStreamLine("LaunchBall) Elapsed Time: %d", nPgmTime - startTime);
	startTask(LauncherStop);
}

task LaunchBall_Right()
{//
	long startTime = nPgmTime;

	LauncherDown_Right_Helper(32);

	writeDebugStreamLine("LaunchBall) Elapsed Time: %d", nPgmTime - startTime);
	startTask(LauncherStop);
}

task LauncherDown_Left()
{//
	LauncherDown_Left_Helper(1);
}

void LauncherDown_Left_Helper(int count)
{
	int index = 1;
	int launcherPower = 90;
	int originalPower = launcherPower;

	startTask(OpenLoader);

	long startTime = nPgmTime;

	do
	{

		//startTask(RotateLoader);

		int primaryPower = launcherPower;

		motor[Launcher1_H] = primaryPower;
		motor[Launcher1_M] = primaryPower;
		motor[Launcher1_L] = primaryPower;
		//wait1Msec(100);

		waitUntil(SensorValue[Launcher1_Ready] == 1);

		//writeDebugStreamLine("LauncherDown_Helper) #2 Launcher1_Ready :%d", SensorValue[Launcher1_Ready]);

		unsigned long cTime = nPgmTime + 1000;

		int loaded = SensorValue[Launcher1_BallLoaded];

		while(loaded == 0 && cTime >= nPgmTime)
		{
			loaded = SensorValue[Launcher1_BallLoaded];

			originalPower = 20;
			primaryPower = originalPower;

			motor[Launcher1_H] = primaryPower;
			motor[Launcher1_M] = primaryPower;
			motor[Launcher1_L] = primaryPower;

			//writeDebugStreamLine("LauncherDown_Helper) #3-1 loaded:%d", loaded);

		}

		//writeDebugStreamLine("LauncherDown_Helper) #3 loaded:%d", loaded);


		if (loaded == 1)
		{

			//wait1Msec(200);

			CloseLoader_Helper();

			originalPower = launcherPower;
			primaryPower = originalPower;

			motor[Launcher1_H] = primaryPower;
			motor[Launcher1_M] = primaryPower;
			motor[Launcher1_L] = primaryPower;


			//writeDebugStreamLine("LauncherDown_Helper) #4 index:%d, Elapsed Time: %d", index, nPgmTime - startTime);


			index++;


			//writeDebugStreamLine("LauncherDown_Helper) #4 loaded:%d", loaded);

			wait1Msec(300);
			if (count >= index)
			{
				//waitUntil(SensorValue[Launcher1_BallLoaded] == 0);
				startTask(OpenLoader);
			}
			wait1Msec(70);

			waitUntil(SensorValue[Launcher1_Ready] == 1);



			//waitUntil(SensorValue[Launcher1_Started] == 1);

			//writeDebugStreamLine("LauncherDown_Helper) #4-1 loaded:%d", SensorValue[Launcher1_Started]);

			//originalPower = 15;
			//primaryPower = originalPower;

			//motor[Launcher1_H] = primaryPower;
			//motor[Launcher1_M] = primaryPower;
			//motor[Launcher1_L] = primaryPower;
		}


		//writeDebugStreamLine("LauncherDown_Helper) #5 Count:%d, index:%d", count, index);

	}
	while(count >= index);


	//writeDebugStreamLine("LauncherDown_Helper) #6 Count:%d, index:%d", count, index);

	startTask(LauncherStop);
	startTask(CloseLoader);

	//stopTask(RotateLoader);

	return;
}

task LauncherDown_Right()
{//
	LauncherDown_Right_Helper(1);
}

void LauncherDown_Right_Helper(int count)
{
	int index = 1;
	int launcherPower = 90;
	int originalPower = launcherPower;

	startTask(OpenLoader_Right);

	long startTime = nPgmTime;

	do
	{

		//startTask(RotateLoader);

		int primaryPower = launcherPower;

		motor[Launcher2_H] = primaryPower;
		motor[Launcher2_M] = primaryPower;
		motor[Launcher2_L] = primaryPower;
		//wait1Msec(100);

		waitUntil(SensorValue[Launcher2_Ready] == 1);

		//writeDebugStreamLine("LauncherDown_Helper) #2 Launcher1_Ready :%d", SensorValue[Launcher1_Ready]);

		unsigned long cTime = nPgmTime + 1000;

		int loaded = SensorValue[Launcher2_BallLoaded];

		while(loaded == 0 && cTime >= nPgmTime)
		{
			loaded = SensorValue[Launcher2_BallLoaded];

			originalPower = 20;
			primaryPower = originalPower;

			motor[Launcher2_H] = primaryPower;
			motor[Launcher2_M] = primaryPower;
			motor[Launcher2_L] = primaryPower;


			//writeDebugStreamLine("LauncherDown_Helper) #3-1 loaded:%d", loaded);

		}

		//writeDebugStreamLine("LauncherDown_Helper) #3 loaded:%d", loaded);


		if (loaded == 1)
		{

			//wait1Msec(200);

			CloseLoader_Right_Helper();

			originalPower = launcherPower;
			primaryPower = originalPower;

			motor[Launcher2_H] = primaryPower;
			motor[Launcher2_M] = primaryPower;
			motor[Launcher2_L] = primaryPower;


			//writeDebugStreamLine("LauncherDown_Helper) #4 index:%d, Elapsed Time: %d", index, nPgmTime - startTime);


			index++;


			//writeDebugStreamLine("LauncherDown_Helper) #4 loaded:%d", loaded);

			wait1Msec(300);
			if (count >= index)
			{
				//waitUntil(SensorValue[Launcher1_BallLoaded] == 0);
				startTask(OpenLoader_Right);
			}
			wait1Msec(70);

			waitUntil(SensorValue[Launcher2_Ready] == 1);



			//waitUntil(SensorValue[Launcher1_Started] == 1);

			//writeDebugStreamLine("LauncherDown_Helper) #4-1 loaded:%d", SensorValue[Launcher1_Started]);

			//originalPower = 15;
			//primaryPower = originalPower;

			//motor[Launcher1_H] = primaryPower;
			//motor[Launcher1_M] = primaryPower;
			//motor[Launcher1_L] = primaryPower;
		}


		//writeDebugStreamLine("LauncherDown_Helper) #5 Count:%d, index:%d", count, index);

	}
	while(count >= index);


	//writeDebugStreamLine("LauncherDown_Helper) #6 Count:%d, index:%d", count, index);

	startTask(LauncherStop);
	startTask(CloseLoader_Right);

	//stopTask(RotateLoader);

	return;
}

task OpenLoader()
{//
	//waitUntil(SensorValue[Launcher1_Started] == 1);
	OpenLoader_Helper();
}

task OpenLoader_Right()
{//
	//waitUntil(SensorValue[Launcher1_Started] == 1);
	OpenLoader_Right_Helper();
}

void OpenLoader_Helper()
{//
	//waitUntil(SensorValue[Launcher1_Started] == 1);

	motor[Loader1] = 0;

	int powerLoader = 50;
	int timeOut = 100;

	motor[Loader1] = powerLoader;
	//wait1Msec(70);

	unsigned long cTime = nPgmTime + timeOut;
	waitUntil(SensorValue[Launcher1_Loader] <= 1200 || cTime <= nPgmTime);
	//wait1Msec(100);

	motor[Loader1] = 0;
}

void OpenLoader_Right_Helper()
{//
	//waitUntil(SensorValue[Launcher1_Started] == 1);
	motor[Loader2] = 0;

	int powerLoader = 50;
	int timeOut = 100;

	motor[Loader2] = powerLoader;
	//wait1Msec(70);

	unsigned long cTime = nPgmTime + timeOut;
	waitUntil(SensorValue[Launcher2_Loader] >= 1900 || cTime <= nPgmTime);
	//wait1Msec(100);

	motor[Loader2] = 0;
}


task CloseLoader()
{
	CloseLoader_Helper();
}

void CloseLoader_Helper()
{
	int powerLoader = 50;
	int timeOut = 100;

	motor[Loader1] = -powerLoader;
	//wait1Msec(100);

	unsigned long cTime = nPgmTime + timeOut;
	waitUntil(SensorValue[Launcher1_Loader] >= 2100 || cTime <= nPgmTime);
	motor[Loader1] = -5;
}

task CloseLoader_Right()
{
	CloseLoader_Right_Helper();
}

void CloseLoader_Right_Helper()
{
	int powerLoader = 50;
	int timeOut = 100;

	motor[Loader2] = -powerLoader;
	//wait1Msec(100);

	unsigned long cTime = nPgmTime + timeOut;
	waitUntil(SensorValue[Launcher2_Loader] <= 1100 || cTime <= nPgmTime);
	motor[Loader2] = -5;
}

task RotateLoader()
{//
	//waitUntil(SensorValue[Launcher1_Started] == 1);

	int powerLoader = 50;
	int timeOut = 100;
	motor[Loader1] = powerLoader;
	wait1Msec(70);


	unsigned long cTime = nPgmTime + timeOut;


	waitUntil(SensorValue[Launcher1_Loader] <= 1200 || cTime <= nPgmTime);

	//wait1Msec(100);

	motor[Loader1] = 0;

	cTime = nPgmTime + 400;
	//waitUntil(cTime <= nPgmTime);
	waitUntil(SensorValue[Launcher1_BallLoaded] == 1 || cTime <= nPgmTime);
	//wait1Msec(70);

	motor[Loader1] = -powerLoader;
	wait1Msec(100);

	cTime = nPgmTime + timeOut;
	waitUntil(SensorValue[Launcher1_Loader] >= 2100 || cTime <= nPgmTime);
	motor[Loader1] = 0;


	//waitUntil(SensorValue[Launcher1_BallLoaded] == 0);


	//motor[Loader1] = powerLoader;

	//waitUntil(SensorValue[Launcher1_Loader] <= 1760);


	//motor[Loader1] = 0;

}

task LauncherUp()
{// T3
	//stopTask(LauncherStop);

	int originalPower = -110;
	int primaryPower = originalPower;

	motor[Launcher1_H] = primaryPower;
	motor[Launcher1_M] = primaryPower;
	motor[Launcher1_L] = primaryPower;

	wait1Msec(70);

	//originalPower =  -19;
	//primaryPower = originalPower;

	//motor[Launcher1] = primaryPower;
	//motor[Launcher2] = primaryPower;
	//motor[Launcher3] = primaryPower;


	startTask(LauncherStop);
}

task LauncherStop()
{
	LauncherStop_Helper();
}

void LauncherStop_Helper()
{
	int power = 0;

	motor[Launcher1_H] = power;
	motor[Launcher1_M] = power;
	motor[Launcher1_L] = power;
	motor[Launcher2_H] = power;
	motor[Launcher2_M] = power;
	motor[Launcher2_L] = power;
}
