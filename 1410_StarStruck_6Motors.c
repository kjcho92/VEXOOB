#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    GyroPosition,   sensorGyro)
#pragma config(Sensor, in7,    Lift,           sensorPotentiometer)
#pragma config(Sensor, I2C_1,  Wheel,          sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           rightThird,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftThird,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightWheel,    tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port5,           leftWheel,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightBot,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftTop,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rightTop,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftBot,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          claw,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

int dist = 0;
int po = 0;
int time = 0;
int AdjustPowerUsingBatteryLevel(int originalPower);
int AdjustPowerUsingExternalBatteryLevel(int originalPower);

void MoveClaw (int ClawPower);
void StopAll();
void LiftUp(int power);
void StartAuto();
void TurnLeft(int turnPower);
void GoStraight(int movePower);
void StopMove();
void TurnRight(int turnPower);
void ClearEncoder();
void MoveValue(int distance, int power);
void UpValue(int distance, int power);
void TurnValue(int distance, int power);
void DownValue(int distance, int power);
void GyroRotate(int power, int distance);
task TurnValueTask();
task Move();



/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	nMotorEncoder[rightWheel] = 0;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	long startTime = nPgmTime;
	int globalDelay = 300;
	// .....................................................................................
	// Autonomous 1: Knocks two stars on the left side of middle fence
	// .....................................................................................

	//StartAuto(); //Opens out claw
	/*MoveValue(600, 75); //Moves to cube
	MoveClaw(100); //Grabs cube
	wait1Msec(500);
	MoveClaw(40); //Hold power
	UpValue(250, 80); //Raises Lift
	TurnValue(160, 50); //Rotates right
	MoveValue(740, 80); //Moves forward
	MoveClaw(-40); //Releases cube
	wait1Msec(500);
	MoveClaw(0);
	MoveValue(275, -50); //Moves back
	MoveClaw(-100); //Opens claw
	wait1Msec(1000);
	MoveClaw(-20); //maintains claw being open
	DownValue(300, -80); //lowers lift to be slightly above fence
	wait1Msec(500);
	MoveValue(250, 80); //move forward to knock more stars
	MoveClaw(100); //close the claw
	wait1Msec(1000);
	MoveClaw(0);*/

	// .....................................................................................
	// Autonomous 2: Grabs three stars at the back side and then the cube
	// .....................................................................................
	//StartAuto(); //Opens out claw
	/*wait1Msec(250);
	MoveValue(550, 75); //Moves forward
	MoveClaw(100); //Grabs stars
	wait1Msec(500);
	MoveClaw(50); //Hold power
	UpValue(200, 80); //Lifts up
	TurnValue(175, -50); //Turns left
	wait1Msec(globalDelay);
	MoveValue(550, -85); //Moves back
	wait1Msec(1000);
	TurnValue(375, 50); //Turns right
	wait1Msec(globalDelay);
	LiftUp(40);//Hold power for lift
	MoveValue(675, 75); //Moves forward
	wait1Msec(500);
	LiftUp(0);
	MoveClaw(-100); //drops stars
	wait1Msec(500);
	MoveClaw(0);
	MoveValue(300, -75); //Go back
	wait1Msec(globalDelay);
	MoveClaw(-100); //Open claw a bit wider
	wait1Msec(150);
	MoveClaw(0);
	TurnValue(325, -50); //Turn left
	wait1Msec(globalDelay);
	DownValue(2000, -80);
	wait1Msec(globalDelay);
	MoveValue(300, 75);
	wait1Msec(globalDelay);
	MoveClaw(100);
	wait1Msec(500);
	MoveClaw(50);
	UpValue(250, 80);
	wait1Msec(globalDelay);
	TurnValue(275, 50);
	wait1Msec(globalDelay);
	MoveValue(500, 75);
	wait1Msec(globalDelay);
	MoveClaw(-100);
	wait1Msec(500);
	MoveClaw(0);*/

	// .....................................................................................
	// Autonomous 3 (Test): Grabs three stars at the back side and then the cube
	// .....................................................................................

	/*
	StartAuto(); //Opens out claw
	wait1Msec(250);
	MoveValue(650, 127); //Moves forward
	MoveClaw(120); //Grabs stars
	wait1Msec(400);
	MoveClaw(50); //Hold power
	dist = 80;
	po = -127;
	time = 700;
	startTask (TurnValueTask); //Turns left
	UpValue(250, 127); //Lifts up
	MoveValue(800, -127); //Moves back
	//MoveClaw(50);//DELETE LATER
	wait1Msec(globalDelay);
	TurnValue(300, 127); //Turns right
	wait1Msec(globalDelay);
	LiftUp(40);//Hold power for lift
	MoveValue(620, 127); //Moves forward and knocks stars over
	wait1Msec(globalDelay);
	LiftUp(0);
	MoveClaw(-120); //drops stars
	wait1Msec(globalDelay);
	MoveClaw(0);
	MoveValue(300, -127); //Go back
	wait1Msec(globalDelay);
	MoveClaw(-120); //Open claw a bit wider
	wait1Msec(100);
	MoveClaw(0);
	dist = 255;
	po = -127;
	time = 0;
	startTask (TurnValueTask); //Turn left to the cube
	wait1Msec(250);
	DownValue(2100, -80);
	wait1Msec(200);
	MoveValue(265, 75); //Move towards the cube
	wait1Msec(200);
	MoveClaw(100);
	wait1Msec(100);
	MoveClaw(70);
	dist = 90;
	po = 127;
	time = 400;
	startTask (TurnValueTask);
	UpValue(250, 127);
	wait1Msec(200);
	MoveValue(590, 127);//move forward to drop the cube
	wait1Msec(200);
	MoveClaw(-100);
	wait1Msec(500);
	MoveClaw(0);
	*/

	// .....................................................................................
	// Autonomous 3 (Test): Grabs three stars at the back side and then the cube
	// .....................................................................................

	StartAuto(); //Opens out claw
	wait1Msec(250);
	MoveValue(650, 127); //Moves forward
	MoveClaw(120); //Grabs stars
	wait1Msec(400);
	MoveClaw(50); //Hold power
	dist = 80;
	po = -127;
	time = 700;
	startTask (TurnValueTask); //Turns left
	UpValue(250, 127); //Lifts up
	MoveValue(800, -127); //Moves back
	//MoveClaw(50);//DELETE LATER
	wait1Msec(globalDelay);
	TurnValue(300, 127); //Turns right
	wait1Msec(globalDelay);
	LiftUp(40);//Hold power for lift
	MoveValue(620, 127); //Moves forward and knocks stars over
	wait1Msec(globalDelay);
	LiftUp(0);
	MoveClaw(-120); //drops stars
	wait1Msec(globalDelay);
	MoveClaw(0);
	MoveValue(300, -127); //Go back
	wait1Msec(globalDelay);
	MoveClaw(-120); //Open claw a bit wider
	wait1Msec(100);
	MoveClaw(0);
	dist = 255;
	po = -127;
	time = 0;
	startTask (TurnValueTask); //Turn left to the cube
	wait1Msec(250);
	DownValue(2100, -80);
	wait1Msec(200);
	MoveValue(265, 75); //Move towards the cube
	wait1Msec(200);
	MoveClaw(100);
	wait1Msec(100);
	MoveClaw(70);
	dist = 90;
	po = 127;
	time = 400;
	startTask (TurnValueTask);
	UpValue(250, 127);
	wait1Msec(200);
	MoveValue(590, 127);//move forward to drop the cube
	wait1Msec(200);
	MoveClaw(-100);
	wait1Msec(500);
	MoveClaw(0);

	writeDebugStreamLine("autonomous) Time: %d", nPgmTime - startTime);
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	startTask (Move);

	while(true)
	{
		if (vexRT[Btn6U] == 1)
		{
			MoveClaw(100);
			wait1Msec(1);
			MoveClaw(10);
		}
		if (vexRT[Btn6D] == 1)
		{
			MoveClaw(-100);
			wait1Msec(10);
			MoveClaw(-5);
		}
		if (vexRT[Btn7U] == 1)
		{
			LiftUp(80);
			wait1Msec(10);
			LiftUp(40);
		}
		if (vexRT[Btn7D] == 1)
		{
			LiftUp(-80);
			wait1Msec(10);
			LiftUp(-20);
		}
		if (vexRT[Btn8L] == 1)
		{
			StopAll();
		}
	}
}



void LiftUp (int power)
{
	motor[leftTop] =	power;
	motor[leftBot] = power;
	motor[rightTop] = power;
	motor[rightBot] = power;
	motor[leftThird]= power;
	motor[rightThird] = power;

}
void MoveClaw (int ClawPower)
{
	motor[claw]= ClawPower;
}

void StopAll()
{
	motor[claw] = 0;

	motor[leftTop] =	0;
	motor[leftBot] = 0;
	motor[rightTop] = 0;
	motor[rightBot] = 0;
	motor[rightThird] = 0;
	motor[leftThird] = 0;
}


void StopMove()
{
	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
}

void StartAuto()
{
	MoveClaw(60);
	wait1Msec(400);
	MoveClaw(-100);
	wait1Msec(350);
	MoveClaw(0);
}

void GoStraight(int movePower)
{
	motor[leftWheel] = -movePower;
	motor[rightWheel] = -movePower;
}
void TurnLeft(int turnPower)
{
	motor[leftWheel] = turnPower;
	motor[rightWheel] = -turnPower;
}

void TurnRight(int turnPower)
{
	motor[leftWheel] = -turnPower;
	motor[rightWheel] = turnPower;
}

void ClearEncoder() {
	nMotorEncoder[rightWheel] = 0;
}

void MoveValue(int distance, int power) {
	ClearEncoder();
	power = AdjustPowerUsingBatteryLevel(power);
	while (abs(nMotorEncoder[rightWheel])<abs(distance)){
		GoStraight(power);
	}
		GoStraight(0);
}

void UpValue(int distance, int power) {
		while (SensorValue(Lift)>distance){
		LiftUp(power);
		}
		LiftUp(0);
}
void DownValue(int distance, int power){
		while (SensorValue(Lift) < distance) {
		LiftUp(power);
		}
		LiftUp(0);
	}
void TurnValue(int distance, int power) {
	ClearEncoder();
	power = AdjustPowerUsingBatteryLevel(power);
	while (abs(nMotorEncoder[rightWheel])<abs(distance)){
		TurnRight(power);
	}
		GoStraight(0);
}

task TurnValueTask() {
	wait1Msec(time);
	ClearEncoder();
	po = AdjustPowerUsingBatteryLevel(po);
	while (abs(nMotorEncoder[rightWheel])<abs(dist)){
		TurnRight(po);
	}
		GoStraight(0);
}

task Move ()
{
	while (true)
	{
		motor[leftWheel] = -(vexRT[Ch3] + vexRT[Ch1]);
		motor[rightWheel] = -(vexRT[Ch3] - vexRT[Ch1]);

		EndTimeSlice();
	}
}

int AdjustPowerUsingBatteryLevel(int originalPower)
{
	float batteryLevel = nImmediateBatteryLevel;
	float batteryOffset =	7150 / batteryLevel;
	int adjustedPower = originalPower * batteryOffset;
	//  writeDebugStreamLine("(AjustBattery) BatterLevel: %d - OriginalPower: %d - WantedPower: %d", AdjustBatteryLevel, OriginalPower, WantedPower);
	return adjustedPower;
}

void GyroRotate(int power, int distance)
{
	int current = abs(SensorValue[GyroPosition]);
	float offset = 0;

	if (power == 0) return;

	//power = -power;
	while (current + offset < distance)
	{
		int previous = current;

		RotateHelper(power);

		int current = abs(SensorValue[GyroPosition]);

		offset = current - previous;
		offset = offset * 1.6;
	}

	StopMoving();
}

/*int AdjustPowerUsingExternalBatteryLevel(int originalPower)
{
	float batteryLevel = SensorValue[ExternalBatteryValue] * 3.57;

	float batteryOffset =	7000 / batteryLevel;
	int adjustedPower = originalPower * batteryOffset;
	//  writeDebugStreamLine("(AjustBattery) BatterLevel: %d - OriginalPower: %d - WantedPower: %d", AdjustBatteryLevel, OriginalPower, WantedPower);
	return adjustedPower;
}*/