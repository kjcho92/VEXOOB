#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    ExternalBatteryValue, sensorAnalog)
#pragma config(Sensor, in2,    BallDispenserPosition, sensorPotentiometer)
#pragma config(Sensor, in3,    GyroPosition,   sensorGyro)
#pragma config(Sensor, in4,    LineBallLoaded, sensorLineFollower)
#pragma config(Sensor, in5,    LauncherPosition, sensorNone)
#pragma config(Sensor, dgtl3,  BallLoaded,     sensorTouch)
#pragma config(Sensor, dgtl4,  BallReleased,   sensorTouch)
#pragma config(Sensor, dgtl5,  LauncherReady,  sensorTouch)
#pragma config(Sensor, dgtl7,  SonarSensor,    sensorNone)
#pragma config(Sensor, dgtl10, Led1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, Jumper1,        sensorDigitalIn)
#pragma config(Sensor, I2C_1,  Launcher_I2C,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  FrontLeft_I2C,  sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           Belt,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           FrontLeft,     tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port3,           FrontRight,    tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port4,           Launcher1,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port5,           Launcher2,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           Launcher3,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           BackLeft,      tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port9,           BackRight,     tmotorVex393_MC29, openLoop, driveRight, encoderPort, None)
#pragma config(Motor,  port10,          BallDispenser, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// #pragma config(Motor,  port7,           Launcher4,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

task LauncherUp();
//task LauncherUp_LongMid();
//task LauncherUp_Autonomous();
task LauncherStop();
task LauncherDown();
task LaunchBall();
task LaunchBall_ProgrammingSkill();
//task StopBelt();
//task DispenseBall();
task OpenDispenser();
task CloseDispenser();
task MoveBeltToReadyBall();
task MoveBeltToReadyFirstBall();
task AutoLaunchBall();
task AutoLaunchBall_Full();
//task displayBatteryLevelOnLCD();
task StartBelt();
//task StopAutonomous();

// Global variables

// For a new rubber band
//int powerToDownLauncher = 76;
//int powerToLaunch = 81;
//int powerToStay = 19;

enum GameMode{
	Long = 0,
	LongMid = 1,
	Middle = 2,
	Near = 3,
	Longest = 4,
	Autonomous = 5,
	ProgrammingSkill = 6
};

int powerForDispenser = 80;
// For a used rubber band
GameMode LauncherRange = Long;

//int LaunchOnly_powerToDown = 83;

int globalWaiter = 180;
int powerToDown = 95;
int powerToDown_Autonomous = 85;
int postionToDown = 65;
int powerToStay = 20;

int powerToLaunch = 97;
int timeToStop = 100;

// int powerToLaunch = 91;
// int timeToStop = 85;
// int powerToLaunch = 83;
// int timeToStop = 110;
//int positionToStop = 43;

//int powerToLaunch_Longest = 95;
//int positionToStop_Longest = 1390;

int powerToLaunch_Autonomous = 7;

int powerToLaunch_ProgrammingSkill = 76;
//int positionToStop_ProgrammingSkill = 28;

int powerToLaunch_LongMid = 80;
int positionToStop_LongMid = 35;

//int powerToLaunch_LongMid = 78;
//int positionToStop_LongMid = 40;

int powerToLaunch_Mid = 63;
int positionToStop_Mid = 22;

int powerToLaunch_Short = 35;
int positionToStop_Short = 23;

//int powerToLaunch_Mid = 80;
//int positionToStop_Mid = 1440;
//int positionToStop_Mid = postionToDown + 50;

long lastLaunchTime = 0;

int autonomousMode = 1;

int lineSensorOffset = 120;

bool launchBallMode = false;

int powerOffset = 0;

//int postionToDown = 1280;
//int postionToDown = 2900;

// Position to break launcher

void displayBatteryLevelOnLCD(int autonomousModeValue);
void DisplayAutonomousMode(int autonomousModeValue);
void TravelToTheOtherSide();
//void ForBack(int originalPower, int distance);
void StopMoving();
void StopOrReverseBelt();
int AdjustPowerUsingBatteryLevel(int originalPower);
int AdjustPowerUsingExternalBatteryLevel(int originalPower);
void LauncherUp_Helper();
void LaunchBall_Helper();
void LauncherDown_Helper();
void RotateHelper(int power);
void LaunchBall_Autonomous();
void PickBalls();
void EncoderRotate(int power, int distance);
void EncoderForBack(int power, int distance);
void ForBackHelper(int power);
void LaunchBall_ProgrammingSkill_Helper();
void LaunchBall_Autonomous_Final();
void PickBalls_Left();
void AutoLaunchBall_Full_Helper();
void StopBelt();
void LaunchBallFunction();
void LauncherStop_Helper();
bool LaunchBall_Helper_Test(int i);
void GyroRotate(int power, int distance);
void PickBalls_Right_Gyro();
void PickBalls_Left_Gyro();
void PushFirstBalls();
void PushFirstBalls_Left_Gyro();
void PushFirstBalls_Right_Gyro();
void Autonomous_AutoLaunchBall_Full_Helper();

//void AutoLaunchBall_Full();

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	SensorValue[Led1] = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................

	//if ((short)ExternalBatteryValue < 500)
	//{
	//	startTask(StartBelt);
	//}
	//else

	if (autonomousMode == 6)
	{
		startTask(StartBelt);
	}
	else if (autonomousMode == 5)
	{
		startTask(LaunchBall_ProgrammingSkill);
	}
	else if (autonomousMode == 1 || autonomousMode == 3)
	{
		//startTask(StopAutonomous);
		long startTime = nPgmTime;


		LaunchBall_Autonomous();
		writeDebugStreamLine("autonomous) Launched Elapsed Time: %d", nPgmTime - startTime);

		PickBalls();
		writeDebugStreamLine("autonomous) PickUpBalls Elapsed Time: %d", nPgmTime - startTime);

		wait1Msec(1800);
		writeDebugStreamLine("autonomous) Loaded Elapsed Time: %d", nPgmTime - startTime);

		int beltPower = 90;
		beltPower = AdjustPowerUsingBatteryLevel(beltPower);
		// motor[Belt] = 0;
		//LauncherRange = LongMid;
		LaunchBall_Autonomous_Final();
		writeDebugStreamLine("autonomous) Launched Final Elapsed Time: %d", nPgmTime - startTime);
	}
	else if (autonomousMode == 2 || autonomousMode == 4)
	{
		//startTask(StopAutonomous);
		long startTime = nPgmTime;


		LaunchBall_Autonomous();
		writeDebugStreamLine("autonomous) Launched Elapsed Time: %d", nPgmTime - startTime);

		PushFirstBalls();
		writeDebugStreamLine("autonomous) PushFirstBalls Elapsed Time: %d", nPgmTime - startTime);

		// wait1Msec(1800);
		// writeDebugStreamLine("LaunchBall) Loaded Elapsed Time: %d", nPgmTime - startTime);

		// int beltPower = 90;
		// beltPower = AdjustPowerUsingBatteryLevel(beltPower);
		// motor[Belt] = 0;
		//LauncherRange = LongMid;
		// LaunchBall_Autonomous_Final();
		// writeDebugStreamLine("LaunchBall) Launched Final Elapsed Time: %d", nPgmTime - startTime);

	}
}

//task StopAutonomous
//{
//	while(nPgmTime < 15000)
//	{}
//	stopTask(autonomous);
//}

void PushFirstBalls()
{
	if (autonomousMode == 2)
	{
		PushFirstBalls_Left_Gyro();
	}
	else
	{
		PushFirstBalls_Right_Gyro();
	}
}

void PushFirstBalls_Left_Gyro()
{


	SensorValue[GyroPosition] = 0;
	GyroRotate(50, 80);

	wait1Msec(100);

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(80, 1100);

	wait1Msec(500);

	SensorValue[GyroPosition] = 0;
	GyroRotate(80, 70);

	wait1Msec(500);

	// Push back the first balls
	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(-80, 300);

	wait1Msec(500);

	SensorValue[GyroPosition] = 0;
	GyroRotate(80, 100);

	wait1Msec(500);

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(50, 550);

	wait1Msec(500);

	SensorValue[GyroPosition] = 0;
	GyroRotate(80, 800);

	wait1Msec(500);

	startTask(StartBelt);

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(60, 460);

	wait1Msec(1000);

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(-50, 50);

	wait1Msec(500);

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(60, 100);

	wait1Msec(500);

	SensorValue[GyroPosition] = 0;
	GyroRotate(80, 70);


	/*
	SensorValue[GyroPosition] = 0;
	GyroRotate(60, 88);
	*/
}

void PushFirstBalls_Right_Gyro()
{
	/*SensorValue[GyroPosition] = 0;
	GyroRotate(-48, 80);

	wait1Msec(100);*/

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(80, 800);

	wait1Msec(500);

	SensorValue[GyroPosition] = 0;
	GyroRotate(-80, 70);

	wait1Msec(500);

	// Push back the first balls
	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(-80, 280);

	wait1Msec(500);

	SensorValue[GyroPosition] = 0;
	GyroRotate(-50, 100);

	wait1Msec(500);

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(50, 600);

	wait1Msec(500);

	SensorValue[GyroPosition] = 0;
	GyroRotate(-80, 800);

	wait1Msec(500);

	startTask(StartBelt);

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(60, 500);

	wait1Msec(1000);

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(-50, 50);

	wait1Msec(500);

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(60, 100);

	wait1Msec(500);

	SensorValue[GyroPosition] = 0;
	GyroRotate(-80, 150);
}

void PickBalls()
{
	if (autonomousMode == 1)
	{
		PickBalls_Left_Gyro();
	}
	else
	{
		PickBalls_Right_Gyro();
	}
}

void PickBalls_Left_Gyro()
{
	nMotorEncoder(FrontLeft) = 0;
	EncoderRotate(-40, 40);

	wait1Msec(100);

	startTask(StartBelt);

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(30, 980);

	wait1Msec(100);

	SensorValue[GyroPosition] = 0;
	GyroRotate(60, 88); /*90?*/
}


void PickBalls_Left()
{
	nMotorEncoder(FrontLeft) = 0;
	EncoderRotate(-40, 40);

	wait1Msec(100);

	startTask(StartBelt);

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(30, 1100);

	wait1Msec(100);

	nMotorEncoder(FrontLeft) = 0;
	EncoderRotate(40, 23);
}

void PickBalls_Right_IEM()
{
	nMotorEncoder(FrontLeft) = 0;
	EncoderRotate(40, 97);

	wait1Msec(100);

	startTask(StartBelt);

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(30, 1000);


	wait1Msec(100);

	nMotorEncoder(FrontLeft) = 0;
	EncoderRotate(-60, 115);
	//EncoderRotate(-40, 97);

	//wait1Msec(1500);

	//nMotorEncoder(FrontLeft) = 0;
	//EncoderRotate(-40, 140);

	//LauncherRange = LongMid;
	//startTask(AutoLaunchBall);


	//SonarForBack();


	//EncoderRotate(-40, 80);

	////ForBackHelper(50);
	//nMotorEncoder(FrontLeft) = 0;
	//EncoderForBack(70, 400);
	//wait1Msec(100);
	//SonarRotate(38, 400);
	////nMotorEncoder(FrontLeft) = 0;
	////EncoderRotate(40, 90);
	//wait1Msec(100);
	//startTask(StartBelt);

	//nMotorEncoder(FrontLeft) = 0;
	//EncoderForBack(30, 650);

}

void PickBalls_Right_Gyro()
{
	nMotorEncoder(FrontLeft) = 0;
	EncoderRotate(40, 97);

	wait1Msec(100);

	startTask(StartBelt);

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(30, 1000);


	wait1Msec(100);

	nMotorEncoder(FrontLeft) = 0;

	SensorValue[GyroPosition] = 0;
	GyroRotate(-60, 280);
}


void PickBalls_Right_NoShoot()
{
	nMotorEncoder(FrontLeft) = 0;
	EncoderRotate(40, 97);

	wait1Msec(100);

	startTask(StartBelt);

	nMotorEncoder(FrontLeft) = 0;
	//EncoderForBack(20, 500);

	EncoderForBack(27, 1000);

	wait1Msec(50);

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(50, 500);


}

void RotateHelper(int power)
{
	int adjustedPower = AdjustPowerUsingBatteryLevel(power);

	motor[FrontLeft] = adjustedPower;
	motor[FrontRight] = -adjustedPower;
	motor[BackLeft] = adjustedPower;
	motor[BackRight] = -adjustedPower;
}

void EncoderForBack(int power, int distance)
{
	//if (power <= 0) return;

	int current = abs(nMotorEncoder(FrontLeft));
	float offset = 0;

	// RED only for programming skill
	// power = -power;
	while (current + offset < distance)
	{
		int previous = current;

		ForBackHelper(power);
		//motor[FrontLeft] = power;
		//motor[FrontRight] = power;
		//motor[BackRight] = power;
		//motor[BackLeft] = power;

		int current = abs(nMotorEncoder(FrontLeft));

		offset = current - previous;
		offset = offset * 1.6;
	}

	StopMoving();
}



void ForBackHelper(int power)
{
	int adjustedPower = AdjustPowerUsingBatteryLevel(power);

	motor[FrontLeft] = -adjustedPower;
	motor[FrontRight] = adjustedPower;
	motor[BackLeft] = adjustedPower;
	motor[BackRight] = -adjustedPower;
}

task StartBelt()
{
	int beltPower = 110;
	beltPower = AdjustPowerUsingBatteryLevel(beltPower);
	motor[Belt] = beltPower;
}

void LaunchBall_Autonomous_Final()
{
	LauncherRange = Autonomous;
	for (int i=0;i<=1;)
		// for (int i=0;i<=3;)
	{
		AutoLaunchBall_Full_Helper();
		wait1Msec(200);
		i++;
	}

	motor[Belt] = 0;
}

/*
void LaunchBall_Autonomous_Final_Old()
{

int baseLineSensor = SensorValue[LineBallLoaded];

for(int i=0;i<=1;i++)
{
LauncherDown_Helper();
//startTask(LauncherDown);

// Open the dispenser
startTask(OpenDispenser);

startTask(StartBelt);

// Wait until a ball loaded
clearTimer(T3);
while(SensorValue[BallLoaded] == 0 && (baseLineSensor - SensorValue[LineBallLoaded]) < lineSensorOffset && time1[T3] < 2000)
{
}

motor[Belt] = 0;

// Close the dispenser
startTask(CloseDispenser);
//if (i == 0)
//{
//	wait1Msec(200);
//}
// Timeout and move the launcher to the original position
if(time1[T3] >= 2000)
{
//startTask(LauncherUp);
//startTask(LauncherStop);
LauncherStop_Helper();
wait1Msec(50);
}
else
{
// Ball is loaded, launch the ball
wait1Msec(400);
startTask(LauncherUp_Autonomous);
//startTask(LauncherUp_LongMid);

wait1Msec(150);


}
}

motor[Belt] = 0;
}
*/

void LaunchBall_Autonomous()
{
	// long startTime = nPgmTime;

	int beltPower = 110;
	beltPower = AdjustPowerUsingBatteryLevel(beltPower);
	motor[Belt] = -beltPower;

	wait1Msec(100);
	motor[Belt] = 0;


	beltPower = 80;
	beltPower = AdjustPowerUsingBatteryLevel(beltPower);

	motor[Belt] = beltPower;


	// for (int i=0;i<=0;)
	for (int i=0;i<=3;)
	{
		Autonomous_AutoLaunchBall_Full_Helper();
		wait1Msec(200);
		i++;
	}

	motor[Belt] = 0;

	// writeDebugStreamLine("AutoLaunchBall_Full) Launched Elapsed Time: %d", nPgmTime - startTime);

}

void LaunchBall_Autonomous_old()
{
	// writeDebugStreamLine("(autonomous started) Time: %d, %d", nPgmTime, nSysTime);

	int i = 0;
	int j = 0;
	int baseLineSensor = SensorValue[LineBallLoaded];

	while(true)
	{
		// Repeat for 4 times (4 preloads)
		if (i > 3 || j > 5)
			// if (i > 0 || j > 5)
		{
			break;
		}

		// move backward to aligh balls
		motor[Belt] = -70;
		wait1Msec(150);
		motor[Belt] = 0;


		//int launcherPosition = SensorValue[LauncherPosition];
		//writeDebugStreamLine("LaunchBall) launcherPosition :%d", launcherPosition);

		// Down the launcher
		int originalPower = powerToDown; // power to down the launcher

		if (i <= 3)
		{
			//originalPower += 1;
		}

		int primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
		int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
		// writeDebugStreamLine("LauncherUp) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

		motor[Launcher1] = externalPower;
		motor[Launcher2] = externalPower;
		motor[Launcher3] = primaryPower;
		//motor[Launcher4] = primaryPower;
		//motor[Launcher5] = power;
		//motor[Launcher6] = power;

		// Down until it is lower than the position (1055)
		//clearTimer(T3);
		//while(SensorValue[LauncherPosition] > postionToDown && time1[T3] < 1000)
		//{
		//}

		wait1Msec(globalWaiter);

		// Down and stay waiting a ball loaded
		originalPower = powerToStay;
		primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
		externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
		// writeDebugStreamLine("LauncherUp) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

		motor[Launcher1] = externalPower;
		motor[Launcher2] = externalPower;
		motor[Launcher3] = primaryPower;
		//motor[Launcher4] = primaryPower;
		//motor[Launcher5] = power;
		//motor[Launcher6] = power;

		// Open the dispenser
		startTask(OpenDispenser);

		// Move the fall forward to make a ball ready
		if (i == 0)
		{
			startTask(MoveBeltToReadyFirstBall);
		}
		else
		{
			startTask(MoveBeltToReadyBall);
		}
		// Wait until a ball loaded
		clearTimer(T3);
		// while(SensorValue[BallLoaded] == 0 && time1[T3] < 3000)
		while(SensorValue[BallLoaded] == 0 && (baseLineSensor - SensorValue[LineBallLoaded]) < lineSensorOffset && time1[T3] < 3000)
		{
		}

		// Close the dispenser
		startTask(CloseDispenser);

		j++;

		//if (i == 0)
		//{
		//	wait1Msec(200);
		//motor[Belt] = 0;
		//}
		// Timeout and move the launcher to the original position
		if(time1[T3] >= 2000)
		{
			//startTask(LauncherUp);
			startTask(LauncherStop);
		}
		else
		{
			// Ball is loaded, launch the ball
			wait1Msec(400);
			startTask(LauncherUp);

			//wait1Msec(150);
			//startTask(LauncherStop);

			// Increase
			i++;
		}
		// Delay for 1 sec before the nexr launch
		wait1Msec(700);
	}

	// writeDebugStreamLine("(autonomous stopped) Time: %d, %d", nPgmTime, nSysTime);
}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

// task displayBatteryLevelOnLCD()
void AutonomousSelector(int btnLCD)
{
	writeDebugStreamLine("AutonomousSelector) button: %d", btnLCD);

	bLCDBacklight=true;

	displayBatteryLevelOnLCD(autonomousMode);
	int autonomousModeValue = autonomousMode;

	int button = 0;
	while(true)
	{
		button = nLCDButtons;

		if (button == 2)
		{
			displayBatteryLevelOnLCD(autonomousModeValue);

			bLCDBacklight=false;
			break;
		}
		else if (button == 1)
		{
			if (autonomousModeValue > 1)
			{
				autonomousModeValue--;
			}

			DisplayAutonomousMode(autonomousModeValue);
		}
		else if (button == 4)
		{
			if (autonomousModeValue < 6)
			{
				autonomousModeValue++;
			}

			DisplayAutonomousMode(autonomousModeValue);
		}
	}

	bLCDBacklight=false;
}

void DisplayAutonomousMode(int autonomousModeValue)
{
	writeDebugStreamLine("DisplayAutonomousMode) autonomousModeValue: %d", autonomousModeValue);

	clearLCDLine(0);                                            // Clear line 1 (0) of the LCD
	clearLCDLine(1);                                            // Clear line 2 (1) of the LCD

	string text;
	//}
	switch(autonomousModeValue)
	{
	case 1:
		{
			text = "Left #1 (Shoot)";
			break;
		}
	case 2:
		{
			text = "Left #2 (PickUp)";
			break;
		}
	case 3:
		{
			text = "Right #1 (Shoot)";
			break;
		}
	case 4:
		{
			text = "Right #2 (PickUp)";
			break;
		}
	case 5:
		{
			text = "ProgrammingSkill";
			break;
		}
	case 6:
		{
			text = "Inspection";
			break;
		}
	}

	//Display the Primary Robot battery voltage
	// displayLCDString(0, 0, "Autonomous: ");
	displayLCDString(0, 0, text);

	wait1Msec(500);
}


task displayPowerOffsetOnLCD()
{
	bLCDBacklight = true;

	clearLCDLine(0);                                            // Clear line 1 (0) of the LCD
	clearLCDLine(1);                                            // Clear line 2 (1) of the LCD

	string text;
	sprintf(text, "powerOffset: %d", powerOffset); //Build the value to be displayed

	//Display the Primary Robot battery voltage
	// displayLCDString(0, 0, "Autonomous: ");
	displayLCDString(0, 0, text);

	wait1Msec(800);

	bLCDBacklight = false;
}

void displayBatteryLevelOnLCD(int autonomousModeValue)
{
	writeDebugStreamLine("displayBatteryLevelOnLCD) autonomousModeValue: %d", autonomousModeValue);

	clearLCDLine(0);                                            // Clear line 1 (0) of the LCD
	clearLCDLine(1);                                            // Clear line 2 (1) of the LCD

	autonomousMode = autonomousModeValue;

	string text;
	sprintf(text, "Selected: %d", autonomousMode); //Build the value to be displayed

	//Display the Primary Robot battery voltage
	// displayLCDString(0, 0, "Autonomous: ");
	displayLCDString(0, 0, text);

	wait1Msec(800);

	//while(true)                                                        // An infinite loop to keep the program running until you terminate it
	//{
	clearLCDLine(0);                                            // Clear line 1 (0) of the LCD
	clearLCDLine(1);                                            // Clear line 2 (1) of the LCD

	string mainBattery, externalBattery;

	//Display the Primary Robot battery voltage
	displayLCDString(0, 0, "Primary: ");
	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
	displayNextLCDString(mainBattery);

	//float externalBatteryLevel = SensorValue[ExternalBatteryValue];
	//Display the Backup battery voltage
	displayLCDString(1, 0, "External: ");
	sprintf(externalBattery, "%1.2f%c", (SensorValue[ExternalBatteryValue] * 3.57)/1000.0, 'V');    //Build the value to be displayed
	displayNextLCDString(externalBattery);

	//Short delay for the LCD refresh rate
	wait1Msec(500);
}

void displayBatteryLevelOnLCD_Old()
{
	bLCDBacklight=true;

	clearLCDLine(0);                                            // Clear line 1 (0) of the LCD
	clearLCDLine(1);                                            // Clear line 2 (1) of the LCD

	string text;
	//}
	switch(autonomousMode)
	{
	case 1:
		{
			text = "Left";
			break;
		}
	case 2:
		{
			text = "Right";
			break;
		}
	case 4:
		{
			text = "ProgrammingSkill";
			break;
		}
	}

	//Display the Primary Robot battery voltage
	displayLCDString(0, 0, "Autonomous: ");
	displayLCDString(1, 0, text);

	wait1Msec(500);

	//while(true)                                                        // An infinite loop to keep the program running until you terminate it
	//{
	clearLCDLine(0);                                            // Clear line 1 (0) of the LCD
	clearLCDLine(1);                                            // Clear line 2 (1) of the LCD

	string mainBattery, externalBattery;

	//Display the Primary Robot battery voltage
	displayLCDString(0, 0, "Primary: ");
	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
	displayNextLCDString(mainBattery);

	//float externalBatteryLevel = SensorValue[ExternalBatteryValue];
	//Display the Backup battery voltage
	displayLCDString(1, 0, "External: ");
	sprintf(externalBattery, "%1.2f%c", (SensorValue[ExternalBatteryValue] * 3.57)/1000.0, 'V');    //Build the value to be displayed
	displayNextLCDString(externalBattery);

	//Short delay for the LCD refresh rate
	wait1Msec(500);


	bLCDBacklight=false;



}

int AdjustPowerUsingBatteryLevel(int originalPower)
{
	float batteryLevel = nImmediateBatteryLevel;
	float batteryOffset =	7000 / batteryLevel;
	int adjustedPower = originalPower * batteryOffset;
	//  writeDebugStreamLine("(AjustBattery) BatterLevel: %d - OriginalPower: %d - WantedPower: %d", AdjustBatteryLevel, OriginalPower, WantedPower);
	return adjustedPower;
}

int AdjustPowerUsingExternalBatteryLevel(int originalPower)
{
	float batteryLevel = SensorValue[ExternalBatteryValue] * 3.57;

	float batteryOffset =	7000 / batteryLevel;
	int adjustedPower = originalPower * batteryOffset;
	//  writeDebugStreamLine("(AjustBattery) BatterLevel: %d - OriginalPower: %d - WantedPower: %d", AdjustBatteryLevel, OriginalPower, WantedPower);
	return adjustedPower;
}

task LauncherUp()
{
	LauncherUp_Helper();
}

void LauncherUp_Helper()
{ // Timer
	//startTask(LauncherStop);
	LauncherStop_Helper();

	int originalPower = powerToLaunch + powerOffset;
	int originalPower_external = powerToLaunch + powerOffset;

	//int local_positionToStop = positionToStop;

	int primaryPower = AdjustPowerUsingBatteryLevel(originalPower) * -1;
	int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower_external) * -1;
	// writeDebugStreamLine("LauncherUp) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

	nMotorEncoder(Launcher1) = 0;
	clearTimer(T1);

	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	//motor[Launcher4] = primaryPower;

	clearTimer(T1);
	while(time1[T1] < timeToStop)
	{
	}
	//writeDebugStreamLine("LauncherUp) launcherPosition #1: %d", abs(nMotorEncoder(Launcher4)));

	//while(abs(nMotorEncoder(Launcher4)) < local_positionToStop && time1[T1] < 1000)
	//{
	//}

	// writeDebugStreamLine("LauncherUp) launcherPosition #1: %d", abs(nMotorEncoder(Launcher4)));

	//int extPower = 20;
	//motor[Launcher1] = extPower;
	//motor[Launcher2] = extPower;
	//motor[Launcher3] = extPower;
	//motor[Launcher4] = extPower;
	//wait1Msec(70);

	//startTask(LauncherStop);
	LauncherStop_Helper();
	// writeDebugStreamLine("LauncherUp) launcherPosition #2: %d", abs(nMotorEncoder(Launcher4)));

}

/*void LauncherUp_Helper_IEM()
{
	startTask(LauncherStop);

	int originalPower = powerToLaunch;
	int originalPower_external = powerToLaunch;

	int local_positionToStop = positionToStop;

	int primaryPower = AdjustPowerUsingBatteryLevel(originalPower) * -1;
	int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower_external) * -1;
	writeDebugStreamLine("LauncherUp) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

	nMotorEncoder(Launcher4) = 0;
	clearTimer(T1);

	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	motor[Launcher4] = primaryPower;

	clearTimer(T1);
	//while(time1[T1] < 120)
	//{
	//}
	//writeDebugStreamLine("LauncherUp) launcherPosition #1: %d", abs(nMotorEncoder(Launcher4)));

	while(abs(nMotorEncoder(Launcher4)) < local_positionToStop && time1[T1] < 1000)
	{
	}

	writeDebugStreamLine("LauncherUp) launcherPosition #1: %d", abs(nMotorEncoder(Launcher4)));

	//int extPower = 20;
	//motor[Launcher1] = extPower;
	//motor[Launcher2] = extPower;
	//motor[Launcher3] = extPower;
	//motor[Launcher4] = extPower;
	//wait1Msec(70);

	startTask(LauncherStop);
	writeDebugStreamLine("LauncherUp) launcherPosition #2: %d", abs(nMotorEncoder(Launcher4)));

}*/

//task LauncherUp_Longest()
//{
//	startTask(LauncherStop);

//	//int positionToStop = 1480;

//	int originalPower = powerToLaunch_Longest;
//	int originalPower_external = powerToLaunch_Longest;

//	int primaryPower = AdjustPowerUsingBatteryLevel(originalPower) * -1;
//	int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower_external) * -1;
//	writeDebugStreamLine("LauncherUp_Short) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

//	motor[Launcher1] = externalPower;
//	motor[Launcher2] = externalPower;
//	motor[Launcher3] = primaryPower;
//	motor[Launcher4] = primaryPower;

//	clearTimer(T1);
//	while(time1[T1] < 130)
//		//while(SensorValue[LauncherPosition] < positionToStop_Longest && time1[T1] < 500)
//	{
//	}

//	//if (time1[T1] > 500)
//	//{
//	//	startTask(LauncherStop);
//	//	return;
//	//}

//	startTask(LauncherStop);
//	//int power1 = 0;
//	//motor[Launcher1] = power1;
//	//motor[Launcher2] = power1;
//	//motor[Launcher3] = power1;
//	//motor[Launcher4] = power1;
//}

task LauncherUp_ProgrammingSkill()
{ // Timer
/*	startTask(LauncherStop);

	int originalPower = powerToLaunch_ProgrammingSkill;
	int originalPower_external = powerToLaunch_ProgrammingSkill;
	int local_positionToStop = positionToStop_ProgrammingSkill;

	int primaryPower = AdjustPowerUsingBatteryLevel(originalPower) * -1;
	int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower_external) * -1;
	// writeDebugStreamLine("LauncherUp_Mid_Global) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

	nMotorEncoder(Launcher4) = 0;
	clearTimer(T1);

	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	motor[Launcher4] = primaryPower;

	while(abs(nMotorEncoder(Launcher4)) < local_positionToStop && time1[T1] < 500)
	{
	}


	startTask(LauncherStop);
*/
	LauncherStop_Helper();

	int originalPower = powerToLaunch_ProgrammingSkill + powerOffset;
	int originalPower_external = powerToLaunch_ProgrammingSkill + powerOffset;

	int primaryPower = AdjustPowerUsingBatteryLevel(originalPower) * -1;
	int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower_external) * -1;

	nMotorEncoder(Launcher1) = 0;
	clearTimer(T1);

	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	//motor[Launcher4] = primaryPower;

	clearTimer(T1);
	while(time1[T1] < 80)
	{
	}

	LauncherStop_Helper();
}

task LauncherUp_LongMid_Global()
{
	startTask(LauncherStop);

	int originalPower = powerToLaunch_LongMid;
	int originalPower_external = powerToLaunch_LongMid;
	int local_positionToStop = positionToStop_LongMid;

	if (LauncherRange == Autonomous)
	{
		originalPower = powerToLaunch_Autonomous;
		originalPower_external = powerToLaunch_Autonomous;
		local_positionToStop = positionToStop_LongMid;

	}

	int primaryPower = AdjustPowerUsingBatteryLevel(originalPower) * -1;
	int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower_external) * -1;
	writeDebugStreamLine("LauncherUp_Autonomous) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

	nMotorEncoder(Launcher1) = 0;
	clearTimer(T1);

	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	//motor[Launcher4] = primaryPower;

	while(abs(nMotorEncoder(Launcher1)) < local_positionToStop && time1[T1] < 1000)
	{
	}

	//int extPower = 20;
	//motor[Launcher1] = extPower;
	//motor[Launcher2] = extPower;
	//motor[Launcher3] = extPower;
	//motor[Launcher4] = extPower;
	//wait1Msec(70);

	startTask(LauncherStop);
}

/*
task LauncherUp_Autonomous()
{
startTask(LauncherStop);

int originalPower = powerToLaunch_Autonomous;
int originalPower_external = powerToLaunch_Autonomous;

int local_positionToStop = positionToStop_LongMid;

int primaryPower = AdjustPowerUsingBatteryLevel(originalPower) * -1;
int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower_external) * -1;
writeDebugStreamLine("LauncherUp_Autonomous) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

nMotorEncoder(Launcher4) = 0;
clearTimer(T1);

motor[Launcher1] = externalPower;
motor[Launcher2] = externalPower;
motor[Launcher3] = primaryPower;
motor[Launcher4] = primaryPower;

while(abs(nMotorEncoder(Launcher4)) < local_positionToStop && time1[T1] < 1000)
{
}

//int extPower = 20;
//motor[Launcher1] = extPower;
//motor[Launcher2] = extPower;
//motor[Launcher3] = extPower;
//motor[Launcher4] = extPower;
//wait1Msec(70);

startTask(LauncherStop);
}

task LauncherUp_LongMid()
{
startTask(LauncherStop);

int originalPower = powerToLaunch_LongMid;
int originalPower_external = powerToLaunch_LongMid;

int local_positionToStop = positionToStop_LongMid;

int primaryPower = AdjustPowerUsingBatteryLevel(originalPower) * -1;
int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower_external) * -1;
writeDebugStreamLine("LauncherUp_LongMid) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

nMotorEncoder(Launcher4) = 0;
clearTimer(T1);

motor[Launcher1] = externalPower;
motor[Launcher2] = externalPower;
motor[Launcher3] = primaryPower;
motor[Launcher4] = primaryPower;

while(abs(nMotorEncoder(Launcher4)) < local_positionToStop && time1[T1] < 1000)
{
}

//int extPower = 20;
//motor[Launcher1] = extPower;
//motor[Launcher2] = extPower;
//motor[Launcher3] = extPower;
//motor[Launcher4] = extPower;
//wait1Msec(70);

startTask(LauncherStop);
}
*/

task LauncherUp_Mid_Global()
{
	startTask(LauncherStop);

	int originalPower = powerToLaunch_Short;
	int originalPower_external = powerToLaunch_Short;
	int local_positionToStop = positionToStop_Short;

	if (LauncherRange == Middle)
	{
		originalPower = powerToLaunch_Mid;
		originalPower_external = powerToLaunch_Mid;
		local_positionToStop = positionToStop_Mid;
	}

	int primaryPower = AdjustPowerUsingBatteryLevel(originalPower) * -1;
	int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower_external) * -1;
	// writeDebugStreamLine("LauncherUp_Mid_Global) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

	nMotorEncoder(Launcher1) = 0;
	clearTimer(T1);

	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	//motor[Launcher4] = primaryPower;

	while(abs(nMotorEncoder(Launcher1)) < local_positionToStop && time1[T1] < 500)
	{
	}

	int extPower = 20;
	motor[Launcher1] = extPower;
	motor[Launcher2] = extPower;
	motor[Launcher3] = extPower;
	//motor[Launcher4] = extPower;
	wait1Msec(70);

	startTask(LauncherStop);
}

/*
task LauncherUp_Mid()
{
startTask(LauncherStop);

int originalPower = powerToLaunch_Mid;
int originalPower_external = powerToLaunch_Mid;

int local_positionToStop = positionToStop_Mid;

int primaryPower = AdjustPowerUsingBatteryLevel(originalPower) * -1;
int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower_external) * -1;
writeDebugStreamLine("LauncherUp_Mid) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

nMotorEncoder(Launcher4) = 0;
clearTimer(T1);

motor[Launcher1] = externalPower;
motor[Launcher2] = externalPower;
motor[Launcher3] = primaryPower;
motor[Launcher4] = primaryPower;

while(abs(nMotorEncoder(Launcher4)) < local_positionToStop && time1[T1] < 500)
{
}

int extPower = 20;
motor[Launcher1] = extPower;
motor[Launcher2] = extPower;
motor[Launcher3] = extPower;
motor[Launcher4] = extPower;
wait1Msec(70);

startTask(LauncherStop);
}

task LauncherUp_Short()
{
startTask(LauncherStop);

int originalPower = powerToLaunch_Short;
int originalPower_external = powerToLaunch_Short;

int local_positionToStop = positionToStop_Short;

int primaryPower = AdjustPowerUsingBatteryLevel(originalPower) * -1;
int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower_external) * -1;
// writeDebugStreamLine("LauncherUp_Short) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

nMotorEncoder(Launcher4) = 0;
clearTimer(T1);

motor[Launcher1] = externalPower;
motor[Launcher2] = externalPower;
motor[Launcher3] = primaryPower;
motor[Launcher4] = primaryPower;

//int local_positionToStop = 20;
//wait1Msec(35);
//unsigned long time = nPgmTime + 85;
//while(nPgmTime < time)
//while(SensorValue[LauncherPosition] < local_positionToStop && time1[T1] < 500)
//for(int i=0;i<3500;i++)
while(abs(nMotorEncoder(Launcher4)) < local_positionToStop && time1[T1] < 500)
{
}

int extPower = 20;
motor[Launcher1] = extPower;
motor[Launcher2] = extPower;
motor[Launcher3] = extPower;
motor[Launcher4] = extPower;
wait1Msec(70);

startTask(LauncherStop);
}
*/
task LauncherStop()
{
	LauncherStop_Helper();
}

void LauncherStop_Helper()
{
	int power = 0;

	motor[Launcher1] = power;
	motor[Launcher2] = power;
	motor[Launcher3] = power;
	//motor[Launcher4] = power;
}

task LauncherDown()
{
	LauncherDown_Helper();
/*
	int local_positionToStop = postionToDown;
	int originalPower = powerToDown;
	int primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
	int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
	// writeDebugStreamLine("LauncherDown_Helper) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

	nMotorEncoder(Launcher4) = 0;

	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	motor[Launcher4] = primaryPower;


	unsigned long startTime = nPgmTime;
	while(nPgmTime - startTime < 80)
	{}

	while(abs(nMotorEncoder(Launcher4)) < local_positionToStop && (nPgmTime - startTime) < globalWaiter)
	{
	}

	writeDebugStreamLine("LauncherDown_Helper #1) LauncherPosition: %d", abs(nMotorEncoder(Launcher4)));

	originalPower = powerToStay;
	primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
	externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	motor[Launcher4] = primaryPower;

	writeDebugStreamLine("LauncherDown_Helper #2) LauncherPosition: %d", abs(nMotorEncoder(Launcher4)));*/
}



void LauncherDown_Helper_IEM()
{
	int local_positionToStop = postionToDown;
	int originalPower = powerToDown;
	int primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
	int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
	// writeDebugStreamLine("LauncherDown_Helper) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

	nMotorEncoder(Launcher1) = 0;

	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	//motor[Launcher4] = primaryPower;


	long startTime = nPgmTime;
	while(nPgmTime - startTime < 80)
	{}

	while(abs(nMotorEncoder(Launcher1)) < local_positionToStop && (nPgmTime - startTime) < globalWaiter)
	{
	}

	writeDebugStreamLine("LauncherDown_Helper #1) LauncherPosition: %d", abs(nMotorEncoder(Launcher1)));

	originalPower = powerToStay;
	primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
	externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	//motor[Launcher4] = primaryPower;

	writeDebugStreamLine("LauncherDown_Helper #2) LauncherPosition: %d", abs(nMotorEncoder(Launcher1)));
}

void LauncherDown_Helper_IEM_Old()
{
	int power = motor[Launcher1];

	if (power != 0)
	{
		return;
	}

	int local_positionToStop = postionToDown;
	int originalPower = powerToDown;
	int primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
	int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
	writeDebugStreamLine("LauncherDown_Helper) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);


	nMotorEncoder(Launcher1) = 0;
	clearTimer(T1);

	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	//motor[Launcher4] = primaryPower;

	while(abs(nMotorEncoder(Launcher1)) < local_positionToStop && time1[T1] < 1000)
	{
	}

	writeDebugStreamLine("LauncherDown_Helper #1) LauncherPosition: %d", abs(nMotorEncoder(Launcher1)));

	originalPower = powerToStay;
	primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
	externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	//motor[Launcher4] = primaryPower;

	writeDebugStreamLine("LauncherDown_Helper #2) LauncherPosition: %d", abs(nMotorEncoder(Launcher1)));

}

//void LaunchOnly_LauncherDown_Helper()
//{
//	int originalPower = LaunchOnly_powerToDown;
//	int primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
//	int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
//	writeDebugStreamLine("LauncherDown_Helper) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

//	motor[Launcher1] = externalPower;
//	motor[Launcher2] = externalPower;
//	motor[Launcher3] = primaryPower;
//	motor[Launcher4] = primaryPower;

//	wait1Msec(globalWaiter);

//	originalPower = powerToStay;
//	primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
//	externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
//	writeDebugStreamLine("LauncherDown_Helper) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

//	motor[Launcher1] = externalPower;
//	motor[Launcher2] = externalPower;
//	motor[Launcher3] = primaryPower;
//	motor[Launcher4] = primaryPower;

//}

void Autonomous_LauncherDown_Helper()
{
	int originalPower = powerToDown_Autonomous;
	int primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
	int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
	// writeDebugStreamLine("LauncherDown_Helper) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	//motor[Launcher4] = primaryPower;

	wait1Msec(globalWaiter);

	originalPower = powerToStay;
	primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
	externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
	// writeDebugStreamLine("LauncherDown_Helper) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	//motor[Launcher4] = primaryPower;

}

void LauncherDown_Helper()
{
	int originalPower = powerToDown;
	int primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
	int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
	// writeDebugStreamLine("LauncherDown_Helper) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	//motor[Launcher4] = primaryPower;

	wait1Msec(globalWaiter);

	originalPower = powerToStay;
	primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
	externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
	// writeDebugStreamLine("LauncherDown_Helper) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	//motor[Launcher4] = primaryPower;

}

task LaunchBall()
{
	launchBallMode = true;
	long startTime = nPgmTime;

	while(true)
	// for (int i=0;i<24;i++)
	{
		LaunchBall_Helper();

		wait1Msec(150);
	}

	writeDebugStreamLine("LaunchBall) Launched Elapsed Time: %d", nPgmTime - startTime);

	launchBallMode = false;

/*	for (int i=0;i<3;i++)
	{
		bool result = LaunchBall_Helper_Test(i);
		if (result == true)
		{
			wait1Msec(150);
		}
		else
		{
			wait1Msec(50);
		}

	}*/
}

void LaunchBallFunction()
{
	//for (int i=0;i<10;i++)
	while(true)
	{
		LaunchBall_Helper();
	}
}

bool LaunchBall_Helper_Test(int i)
{
	// LauncherStop_Helper();
	// startTask(LauncherDown);
	LauncherDown_Helper();

	clearTimer(T3);
	while(SensorValue[BallLoaded] == 0 /*&& time1[T3] < 2000*/)
	{
	}

	// SensorValue[Led1] = false;

	//stopTask(LauncherDown);

	if (SensorValue[BallLoaded] == 1)
	{
		//wait1Msec(450);
		wait1Msec(300);

		if (LauncherRange == ProgrammingSkill)
		{
			startTask(LauncherUp_ProgrammingSkill);
		}
		else
		{
			// startTask(LauncherUp);
			LauncherUp_Helper();
		}

		//if (LauncherRange == Near)
		//{
		//	startTask(LauncherUp_Short);
		//}
		//else if (LauncherRange == Middle)
		//{
		//	startTask(LauncherUp_Mid);
		//}
		//else if (LauncherRange == LongMid)
		//{
		//	startTask(LauncherUp_LongMid);
		//}
		//else if (LauncherRange == Longest)
		//{
		//	startTask(LauncherUp_Longest);
		//}
		//else
		//{
		//	startTask(LauncherUp);
		//}
		wait1Msec(200);
		//startTask(LauncherStop);
		//wait1Msec(100);
		return true;
	}
	else
	{
		// startTask(LauncherStop);
		LauncherStop_Helper();
		return false;
	}

/*

	clearTimer(T3);
	while(SensorValue[BallLoaded] == 0 && time1[T3] < 4000)
	{
	}

	if (SensorValue[BallLoaded] == 1)
	{
		//wait1Msec(450);
		wait1Msec(300);

		LauncherUp_Helper();

		wait1Msec(1000);
		//startTask(LauncherStop);
		//wait1Msec(100);
	}
	else
	{
		LauncherStop_Helper();
	}
*/
}

void LaunchBall_Helper()
{
	//LauncherStop_Helper();

	// SensorValue[Led1] = true;

	//LaunchOnly_LauncherDown_Helper();
	LauncherDown_Helper();

	nMotorEncoder(Launcher1) = 0;
	// startTask(LauncherDown);

	clearTimer(T3);

	int ballLoaded = 0;

	int baseLineSensor = SensorValue[LineBallLoaded];

	while(ballLoaded == 0 && time1[T3] < 4000)
	{
		ballLoaded = SensorValue[BallLoaded] + ((baseLineSensor - SensorValue[LineBallLoaded]) > lineSensorOffset)? 1 : 0;
	}

	/*while(SensorValue[BallLoaded] == 0 && time1[T3] < 4000)
	{
	}*/

	// SensorValue[Led1] = false;

	//stopTask(LauncherDown);

	if ((baseLineSensor - SensorValue[LineBallLoaded]) > lineSensorOffset || ballLoaded == 1)
	{
		//wait1Msec(450);
		wait1Msec(300);

		if (LauncherRange == ProgrammingSkill)
		{
			startTask(LauncherUp_ProgrammingSkill);
		}
		else
		{
			startTask(LauncherUp);
		}

		//if (LauncherRange == Near)
		//{
		//	startTask(LauncherUp_Short);
		//}
		//else if (LauncherRange == Middle)
		//{
		//	startTask(LauncherUp_Mid);
		//}
		//else if (LauncherRange == LongMid)
		//{
		//	startTask(LauncherUp_LongMid);
		//}
		//else if (LauncherRange == Longest)
		//{
		//	startTask(LauncherUp_Longest);
		//}
		//else
		//{
		//	startTask(LauncherUp);
		//}
		wait1Msec(150);
		//startTask(LauncherStop);
		//wait1Msec(100);
	}
	else
	{
		startTask(LauncherStop);
	}
}

task LaunchBall_ProgrammingSkill()
{
	LaunchBall_ProgrammingSkill_Helper();
}

/*void LaunchBall_ProgrammingSkill_Helper_Short()
{ // Skills

	// long startTime = nPgmTime;
	LauncherRange = ProgrammingSkill;

	//int i = 0;
	for (int i=0;i<64;)
		// while(true)
	{
		//{
		LaunchBall_Helper();
		i++;

		if (i == 32)
			// if (i == 32)
		{
			//LauncherRange = Long;
			wait1Msec(100);

			long startTime = nPgmTime;
			TravelToTheOtherSide();
			writeDebugStreamLine("ProgrammingSkill) Moved Elapsed Time: %d", nPgmTime - startTime);

			wait1Msec(300); // Skill

		}
	}
}*/

void LaunchBall_ProgrammingSkill_Helper()
{ // Skills
	LauncherRange = Long;

	int i = 0;
	while(true)
	// for (int i=0;i<4;)
	{
		//{
		LaunchBall_Helper();
		i++;

		if (i == 32)
		{
			//LauncherRange = Long;

			TravelToTheOtherSide();
			wait1Msec(300); // Skill

		}
	}
}

void LaunchBall_ProgrammingSkill_Turn_Helper()
{ // Skills
	int i = 0;
	while(true)
	{
		stopTask(LauncherUp);
		startTask(LauncherStop);

		//int launcherPosition = SensorValue[LauncherPosition];
		//writeDebugStreamLine("LaunchBall) launcherPosition :%d", launcherPosition);

		LauncherDown_Helper();
		//clearTimer(T3);
		//while(SensorValue[LauncherPosition] > postionToDown /* - 10*/ && time1[T3] < 1000)
		//{
		//}

		clearTimer(T3);
		while(SensorValue[BallLoaded] == 0 && time1[T3] < 1000)
		{
		}
		i++;
		if(time1[T3] >= 1000)
		{
			//startTask(LauncherUp);
			startTask(LauncherStop);

		}
		else
		{
			wait1Msec(330); // Skill
			startTask(LauncherUp);
			//wait1Msec(500); // Drive
			//if (LauncherRange == Longest)
			//{
			//	startTask(LauncherUp_Longest);
			//}
			//else
			//{
			//	startTask(LauncherUp);
			//}
			//startTask(LauncherUp_Skill);

			//wait1Msec(150);
			//startTask(LauncherStop);
		}
		if (i == 32)
		{
			TravelToTheOtherSide();
			wait1Msec(300); // Skill
		}

		wait1Msec(300); // Skill

		//wait1Msec(300); // Drive
	}
}

void GyroRotate(int power, int distance)
{
	int current = abs(SensorValue[GyroPosition]);
	float offset = 0;

	if (power == 0) return;

	//power = -power;
	while (current + offset < distance)
	{
		int previous = current;

		RotateHelper(power);

		int current = abs(SensorValue[GyroPosition]);

		offset = current - previous;
		offset = offset * 1.6;
	}

	StopMoving();
}

void EncoderRotate(int power, int distance)
{
	int current = abs(nMotorEncoder(FrontLeft));
	float offset = 0;

	if (power == 0) return;

	//power = -power;
	while (current + offset < distance)
	{
		int previous = current;

		RotateHelper(power);

		int current = abs(nMotorEncoder(FrontLeft));

		offset = current - previous;
		offset = offset * 1.6;
	}

	StopMoving();
}


void TravelToTheOtherSide_Straight()
{
	//wait1Msec(100);
	//nMotorEncoder(FrontLeft) = 0;
	//EncoderForBack(30, 100);


	nMotorEncoder(FrontLeft) = 0;
	EncoderRotate(60, 250);

	wait1Msec(100);
	//nMotorEncoder(FrontLeft) = 0;
	//EncoderForBack(-100, 1900);
	ForBackHelper(30);
	wait1Msec(350);
	//wait1Msec(100);

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(-100, 2400);

	ForBackHelper(-30);
	wait1Msec(800);

	StopMoving();

	nMotorEncoder(FrontLeft) = 0;
	EncoderRotate(-60, 50);

}


void TravelToTheOtherSide_New()
{
	SensorValue[GyroPosition] = 0;
	GyroRotate(70, 1000);

	wait1Msec(300);

	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(-80, 1300);

	EncoderForBack(-40, 1520);

	wait1Msec(500);

	SensorValue[GyroPosition] = 0;
	GyroRotate(-60, 1520);

	wait1Msec(300);

	ForBackHelper(-70);

	wait1Msec(520);
	StopMoving();
}

void TravelToTheOtherSide()
{

	// Turn right to the center

	//wait1Msec(100);
	//nMotorEncoder(FrontLeft) = 0;
	//EncoderRotate(-50, 38);

	//wait1Msec(100);

	// Move forward
	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(50, 1400);

	wait1Msec(1000);

	// Turn left to the other side
	nMotorEncoder(FrontLeft) = 0;
	EncoderRotate(50, 290);

	wait1Msec(1000);

	// Move backward
	nMotorEncoder(FrontLeft) = 0;
	EncoderForBack(-60, 1090);


	//ForBackHelper(-30);

	wait1Msec(1000);
	StopMoving();

	//wait1Msec(100);

	// Turn right to the goal
	//nMotorEncoder(FrontRight) = 0;
	//EncoderRotate(-50, 25);

	//wait1Msec(100);
}

void StopMoving()
{
	motor[FrontLeft] = 0;
	motor[FrontRight] = 0;
	motor[BackRight] = 0;
	motor[BackLeft] = 0;
}

task usercontrol()
{
	// User control code here, inside the loop
	LauncherRange = Long;
	startTask(CloseDispenser);

	while (true)
	{
		wait1Msec(50);

		int btnLCD = nLCDButtons;
		if (btnLCD > 0)
		{
			AutonomousSelector(btnLCD);
			// startTask(displayBatteryLevelOnLCD);
		}

		//int btnLCD = nLCDButtons;
		//if (btnLCD >= 2)
		//{
		//	startTask(displayBatteryLevelOnLCD);
		//}
		//else if (btnLCD == 1)
		//{
		//	stopTask(displayBatteryLevelOnLCD);
		//}


		int btn5u = vexRT[Btn5U]; // start belt
		int btn5d = vexRT[Btn5D]; // start belt

		int btn6u = vexRT[Btn6U]; // start belt
		int btn6d = vexRT[Btn6D]; // stop belt

		int btn7u = vexRT[Btn7U]; // Fast Launcher
		int btn7d = vexRT[Btn7D]; // Fast Launcher

		// Launcher Speed
		int btn8u = vexRT[Btn8U]; // Fast Launcher
		int btn8d = vexRT[Btn8D]; // Slow Launcher
		int btn8l = vexRT[Btn8L]; // Slow Launcher
		int btn8r = vexRT[Btn8R]; // Slow Launcher

		int power3 = - vexRT[Ch3]; // forward, backward
		int power1 = vexRT[Ch1]; // rotate
		//if (power1 > 50)
		//{
		//	power1 = power1 * 90 / 100;
		//}

		int btn7r = vexRT[Btn7R]; // shift
		int btn7l = vexRT[Btn7L]; // shift

		//standard drive motor block
		motor[FrontLeft] = power3 - power1;
		motor[FrontRight] = -power3 + power1;//* 90 / 100;
		motor[BackRight] = power3 + power1;// * 90 / 100;
		motor[BackLeft] = -power3 - power1;// * 90 / 100;


		if (btn8u == 1)
		{
			//nMotorEncoder(FrontRight) = 0;
			//ForBack(-80, 1000);
			if (motor[Launcher1] == 0)
			{
			}
			else
			{

				stopTask(LauncherDown);

				wait1Msec(10);


				if (LauncherRange == Near || LauncherRange == Middle)
				{
					startTask(LauncherUp_Mid_Global);
					//startTask(LauncherUp_Mid);
				}
				else if (LauncherRange == LongMid)
				{
					startTask(LauncherUp_LongMid_Global);
				}

				/*if (LauncherRange == Near)
				{
				startTask(LauncherUp_Short);
				}
				else if (LauncherRange == Middle)
				{
				startTask(LauncherUp_Mid);
				}*/
				/*else if (LauncherRange == LongMid)
				{
				startTask(LauncherUp_LongMid);
				}*/
				//else if (LauncherRange == Longest)
				//{
				//	startTask(LauncherUp_Longest);
				//}
				else
				{
					startTask(LauncherUp);
				}
			}
		}
		else if (btn8d == 1)
		{
			// startTask(LaunchBall_ProgrammingSkill);
			LauncherRange = ProgrammingSkill;
			stopTask(LaunchBall);
			startTask(LaunchBall);

			// LaunchBall_ProgrammingSkill_Helper();
			/*			LauncherRange = Near;

			stopTask(LauncherUp);
			startTask(LauncherDown);
			*/
			// long startTime = nPgmTime;

			/*
			SensorValue[GyroPosition] = 0;
			GyroRotate(70, 1000);

			wait1Msec(300);

			nMotorEncoder(FrontLeft) = 0;
			EncoderForBack(-80, 1300);

			EncoderForBack(-40, 1520);

			wait1Msec(500);

			SensorValue[GyroPosition] = 0;
			GyroRotate(-60, 1600);

			wait1Msec(300);

			ForBackHelper(-70);

			wait1Msec(450);*/



			// wait1Msec(500);

			// ForBackHelper(-50);

			// wait1Msec(400);


			// ForBackHelper(-10);


			// wait1Msec(500);

			// SensorValue[GyroPosition] = 0;
			// GyroRotate(-70, 210);


			// writeDebugStreamLine("ProgrammingSkill) Moved Elapsed Time: %d", nPgmTime - startTime);


			// SensorValue[GyroPosition] = 0;
			// GyroRotate(-60, 650);



		}
		else if (btn8l == 1)
		{
			// LauncherRange = ProgrammingSkill;
			stopTask(LaunchBall);

			startTask(LaunchBall);
			//LaunchBallFunction();
		}
		else if (btn8r == 1)
		{
			if (SensorValue[Jumper1] == 0)
			{
				//TravelToTheOtherSide();
			}
			else
			{
				//nMotorEncoder(FrontRight) = 0;
				//EncoderRotate(50, 250);

				// Open or Close the ball dispenser
				if (SensorValue[BallDispenserPosition] >= 1300)
				{
					// Open
					//stopTask(CloseDispenser);
					//startTask(OpenDispenser);
					motor[BallDispenser] = -powerForDispenser;

					clearTimer(T2);
					while(SensorValue[BallDispenserPosition] > 1060 && time1[T2] < 5000)
					{
					}

					motor[BallDispenser] = 0;
				}
				else
				{	// Close
					//stopTask(OpenDispenser);
					//startTask(CloseDispenser);

					motor[BallDispenser] = powerForDispenser;

					clearTimer(T2);
					while(SensorValue[BallDispenserPosition] < 1460 && time1[T2] < 5000)
					{
					}

					motor[BallDispenser] = 0;

				}
			}
		}
		else if (btn6u == 1)
		{
			if (launchBallMode == false)
			{
				int beltPower = 110;
				beltPower = AdjustPowerUsingBatteryLevel(beltPower);

				motor[Belt] = beltPower;
			}
			else
			{
				if (powerOffset < 3)
				{
					powerOffset++;
				}
				startTask(displayPowerOffsetOnLCD);
				wait1Msec(90);
			}
			//motor[Belt] = 80;
		}
		else if (btn6d == 1)
		{
			if (launchBallMode == false)
			{

			//motor[Belt] = 0;

				StopOrReverseBelt();
			}
			else
			{
				if (powerOffset > -3)
				{
					powerOffset--;
				}
				startTask(displayPowerOffsetOnLCD);
				wait1Msec(90);
			}
		}
		else if (btn5u == 1)
		{
			stopTask(AutoLaunchBall);
			wait1Msec(100);

			LauncherRange = Near;
			startTask(AutoLaunchBall);
		}
		else if (btn7u == 1)
		{
			stopTask(AutoLaunchBall);
			wait1Msec(100);

			LauncherRange = Middle;
			startTask(AutoLaunchBall);
		}
		else if (btn7l == 1)
		{
			stopTask(AutoLaunchBall);
			wait1Msec(100);

			LauncherRange = LongMid;
			startTask(AutoLaunchBall);
		}
		else if (btn7d == 1)
		{
			stopTask(AutoLaunchBall);
			wait1Msec(100);

			LauncherRange = Long;
			startTask(AutoLaunchBall);
		}
		else if (btn7r == 1)
		{
			stopTask(AutoLaunchBall);
			stopTask(AutoLaunchBall_Full);
			wait1Msec(100);

			startTask(AutoLaunchBall_Full);
			//AutoLaunchBall_Full();
		}
		else if (btn5d == 1)
		{
			launchBallMode = false;
			motor[Belt] = 0;
			stopTask(LauncherUp);
			stopTask(LauncherDown);
			stopTask(LaunchBall);
			stopTask(AutoLaunchBall);
			stopTask(AutoLaunchBall_Full);
			stopTask(LaunchBall_ProgrammingSkill);
			startTask(LauncherStop);
			startTask(CloseDispenser);
		}
	}
}

void StopOrReverseBelt()
{

	wait1Msec(200);
	int power = motor[Belt];

	if (power != 0)
	{
		StopBelt();
	}
	else
	{
		motor[Belt] = -80;
		wait1Msec(150);
	}
}

//task StopBelt()
void StopBelt()
{
	int power = 0;
	motor[Belt] = power;
}

/*
task DispenseBall()
{
motor[Belt] = 0;
wait1Msec(100);

motor[Belt] = -80;
wait1Msec(100);
motor[Belt] = 0;


startTask(OpenDispenser);

wait1Msec(50);

motor[Belt] = 80;

startTask(CloseDispenser);

wait1Msec(1600);
motor[Belt] = 0;
}
*/
task OpenDispenser()
{// T2
	motor[BallDispenser] = -powerForDispenser;

	clearTimer(T2);
	while(SensorValue[BallDispenserPosition] > 1060 && time1[T2] < 5000)
	{
	}

	motor[BallDispenser] = 0;

}

task CloseDispenser()
{// T2
	//clearTimer(T2);
	//while(SensorValue[BallLoaded] == 0 && time1[T2] < 3000)
	//{
	//}

	motor[BallDispenser] = powerForDispenser;

	clearTimer(T2);
	while(SensorValue[BallDispenserPosition] < 1460 && time1[T2] < 5000)
	{
	}

	motor[BallDispenser] = 0;
}

task AutoLaunchBall_Full()
//void AutoLaunchBall_Full()
{
	long startTime = nPgmTime;

	int beltPower = 110;
	beltPower = AdjustPowerUsingBatteryLevel(beltPower);
	motor[Belt] = -beltPower;

	wait1Msec(150);
	motor[Belt] = 0;


	beltPower = 80;

	// if (LauncherRange == ProgrammingSkill)
	// {
	// 	beltPower = 100;
	// }

	beltPower = AdjustPowerUsingBatteryLevel(beltPower);

	motor[Belt] = beltPower;


	for (int i=0;i<=2;)
		//while(true)
	{
		AutoLaunchBall_Full_Helper();
		wait1Msec(200);
		i++;
	}

	motor[Belt] = 0;

	writeDebugStreamLine("AutoLaunchBall_Full) Launched Elapsed Time: %d", nPgmTime - startTime);
}

void Autonomous_AutoLaunchBall_Full_Helper()
{
	// T2
	SensorValue[Led1] = true;

	Autonomous_LauncherDown_Helper();

	startTask(OpenDispenser);

	clearTimer(T3);
	//bool ballReleased = false;

	int ballReleased = 0;
	int ballLoaded = 0;

	int baseLineSensor = SensorValue[LineBallLoaded];

	while(ballReleased == 0 && ballLoaded == 0 && time1[T3] < 4000)
	{
		ballReleased = SensorValue[BallReleased];
		// ballLoaded = SensorValue[BallLoaded];
		ballLoaded = SensorValue[BallLoaded] + ((baseLineSensor - SensorValue[LineBallLoaded]) > lineSensorOffset)? 1 : 0;
	}

	SensorValue[Led1] = false;

	if (ballReleased > 0)
	{

		wait1Msec(200);

		//ballReleased = true;
	}


	startTask(CloseDispenser);

	lastLaunchTime = nPgmTime;

	if(time1[T3] >= 4000)
	{
		startTask(LauncherStop);
	}
	else if (ballReleased == 1)
	{
		ballLoaded = 0;
		while(ballLoaded == 0 && time1[T3] < 4000)
		{
			// ballLoaded = SensorValue[BallLoaded];
			ballLoaded = SensorValue[BallLoaded] + ((baseLineSensor - SensorValue[LineBallLoaded]) > lineSensorOffset)? 1 : 0;
		}
	}

	// if (SensorValue[BallLoaded] == 1 || ballLoaded == 1)
	if (SensorValue[BallLoaded] == 1 || (baseLineSensor - SensorValue[LineBallLoaded]) > lineSensorOffset || ballLoaded == 1)
	{
		//wait1Msec(450);
		wait1Msec(300);


		if (LauncherRange == Near || LauncherRange == Middle)
		{
			startTask(LauncherUp_Mid_Global);
			//startTask(LauncherUp_Mid);
		}
		else if (LauncherRange == LongMid || LauncherRange == Autonomous)
		{
			startTask(LauncherUp_LongMid_Global);
		}
		else
		{
			startTask(LauncherUp);
		}


		// else if (LauncherRange == ProgrammingSkill)
		// {
		// 	startTask(LauncherUp_ProgrammingSkill);
		// }


		/*if (LauncherRange == Near)
		{
		startTask(LauncherUp_Short);
		//startTask(LauncherUp_Mid);
		}
		else if (LauncherRange == Middle)
		{
		startTask(LauncherUp_Mid);
		}*/
		/*else if (LauncherRange == LongMid)
		{
		startTask(LauncherUp_LongMid);
		}
		else if (LauncherRange == Autonomous)
		{
		startTask(LauncherUp_Autonomous);
		}*/
		//else if (LauncherRange == Longest)
		//{
		//	startTask(LauncherUp_Longest);
		//}
		//wait1Msec(200);
		//startTask(LauncherStop);
	}
	else
	{
		startTask(LauncherStop);
	}
}


void AutoLaunchBall_Full_Helper()
{
	// T2
	SensorValue[Led1] = true;

	LauncherDown_Helper();

	startTask(OpenDispenser);

	clearTimer(T3);
	//bool ballReleased = false;

	int ballReleased = 0;
	int ballLoaded = 0;

	int baseLineSensor = SensorValue[LineBallLoaded];

	while(ballReleased == 0 && ballLoaded == 0 && time1[T3] < 4000)
	{
		ballReleased = SensorValue[BallReleased];
		// ballLoaded = SensorValue[BallLoaded];
		ballLoaded = SensorValue[BallLoaded] + ((baseLineSensor - SensorValue[LineBallLoaded]) > lineSensorOffset)? 1 : 0;
	}

	SensorValue[Led1] = false;

	if (ballReleased > 0)
	{

		wait1Msec(200);

		//ballReleased = true;
	}


	startTask(CloseDispenser);

	lastLaunchTime = nPgmTime;

	if(time1[T3] >= 4000)
	{
		startTask(LauncherStop);
	}
	else if (ballReleased == 1)
	{
		ballLoaded = 0;
		while(ballLoaded == 0 && time1[T3] < 4000)
		{
			// ballLoaded = SensorValue[BallLoaded];
			ballLoaded = SensorValue[BallLoaded] + ((baseLineSensor - SensorValue[LineBallLoaded]) > lineSensorOffset)? 1 : 0;
		}
	}

	// if (SensorValue[BallLoaded] == 1 || ballLoaded == 1)
	if (SensorValue[BallLoaded] == 1 || (baseLineSensor - SensorValue[LineBallLoaded]) > lineSensorOffset || ballLoaded == 1)
	{
		//wait1Msec(450);
		wait1Msec(300);


		if (LauncherRange == Near || LauncherRange == Middle)
		{
			startTask(LauncherUp_Mid_Global);
			//startTask(LauncherUp_Mid);
		}
		else if (LauncherRange == LongMid || LauncherRange == Autonomous)
		{
			startTask(LauncherUp_LongMid_Global);
		}
		else
		{
			startTask(LauncherUp);
		}


		// else if (LauncherRange == ProgrammingSkill)
		// {
		// 	startTask(LauncherUp_ProgrammingSkill);
		// }


		/*if (LauncherRange == Near)
		{
		startTask(LauncherUp_Short);
		//startTask(LauncherUp_Mid);
		}
		else if (LauncherRange == Middle)
		{
		startTask(LauncherUp_Mid);
		}*/
		/*else if (LauncherRange == LongMid)
		{
		startTask(LauncherUp_LongMid);
		}
		else if (LauncherRange == Autonomous)
		{
		startTask(LauncherUp_Autonomous);
		}*/
		//else if (LauncherRange == Longest)
		//{
		//	startTask(LauncherUp_Longest);
		//}
		//wait1Msec(200);
		//startTask(LauncherStop);
	}
	else
	{
		startTask(LauncherStop);
	}
}

/*
task AutoLaunchBall_Full()
//void AutoLaunchBall_Full()
{
long startTime = nPgmTime;

int beltPower = 110;
beltPower = AdjustPowerUsingBatteryLevel(beltPower);
motor[Belt] = -beltPower;

wait1Msec(100);
motor[Belt] = 0;


beltPower = 90;
beltPower = AdjustPowerUsingBatteryLevel(beltPower);

motor[Belt] = beltPower;


for (int i=0;i<=2;)
//while(true)
{
AutoLaunchBall_Full_Helper();
wait1Msec(200);
i++;
}

motor[Belt] = 0;

writeDebugStreamLine("AutoLaunchBall_Full) Launched Elapsed Time: %d", nPgmTime - startTime);
}

void AutoLaunchBall_Full_Helper()
{
// T2
startTask(CloseDispenser);

SensorValue[Led1] = true;


//clearTimer(T3);
//while(SensorValue[LauncherPosition] > postionToDown && time1[T3] < 1000)
//{
//}



//if ((nPgmTime - lastLaunchTime) > 5000)
//{
//	startTask(MoveBeltToReadyFirstBall);
//}
//else
//{
//	startTask(MoveBeltToReadyBall);
//}

//motor[Belt


startTask(OpenDispenser);
LauncherDown_Helper();

clearTimer(T3);
//bool ballReleased = false;

int ballReleased = 0;
int ballLoaded = 0;

int baseLineSensor = SensorValue[LineBallLoaded];

while(ballReleased == 0 && ballLoaded == 0 && time1[T3] < 4000)
{
ballReleased = SensorValue[BallReleased];
// ballLoaded = SensorValue[BallLoaded];
ballLoaded = SensorValue[BallLoaded] + ((baseLineSensor - SensorValue[LineBallLoaded]) > lineSensorOffset)? 1 : 0;
}

SensorValue[Led1] = false;

if (ballReleased > 0)
{

wait1Msec(200);

//ballReleased = true;
}


//if (SensorValue[BallLoaded] > 0)
//{
//	BallLoaded = true;
//}



startTask(CloseDispenser);

lastLaunchTime = nPgmTime;

if(time1[T3] >= 4000)
{
startTask(LauncherStop);
}
else if (ballReleased == 1)
{
ballLoaded = 0;
while(ballLoaded == 0 && time1[T3] < 4000)
{
// ballLoaded = SensorValue[BallLoaded];
ballLoaded = SensorValue[BallLoaded] + ((baseLineSensor - SensorValue[LineBallLoaded]) > lineSensorOffset)? 1 : 0;
}
}

// if (SensorValue[BallLoaded] == 1 || ballLoaded == 1)
if (SensorValue[BallLoaded] == 1 || (baseLineSensor - SensorValue[LineBallLoaded]) > lineSensorOffset || ballLoaded == 1)
{
//wait1Msec(450);
wait1Msec(300);

if (LauncherRange == Near)
{
startTask(LauncherUp_Short);
//startTask(LauncherUp_Mid);
}
else if (LauncherRange == Middle)
{
startTask(LauncherUp_Mid);
}
else if (LauncherRange == LongMid)
{
startTask(LauncherUp_LongMid);
}
//else if (LauncherRange == Longest)
//{
//	startTask(LauncherUp_Longest);
//}
else
{
startTask(LauncherUp);
}
//wait1Msec(200);
//startTask(LauncherStop);
}
else
{
startTask(LauncherStop);
}
}
*/

task AutoLaunchBall()
{
	//int power = motor[Launcher1];

	//if (power != 0)
	//{
	//	return;
	//}

	// T2
	startTask(CloseDispenser);

	int beltPower = 110;
	beltPower = AdjustPowerUsingBatteryLevel(beltPower);
	motor[Belt] = -beltPower;

	//motor[Belt] = -110;
	wait1Msec(150);
	//wait1Msec(200);
	motor[Belt] = 0;

	stopTask(CloseDispenser);

	//int launcherPosition = SensorValue[LauncherPosition];
	//writeDebugStreamLine("LaunchBall) launcherPosition :%d", launcherPosition);


	//if ((nPgmTime - lastLaunchTime) > 5000)
	//{
	//	originalPower += 4;
	//}

	SensorValue[Led1] = true;

	LauncherDown_Helper();

	startTask(OpenDispenser);
	wait1Msec(80);
	//OpenDispenser_Helper();

	if ((nPgmTime - lastLaunchTime) > 5000)
	{
		startTask(MoveBeltToReadyFirstBall);
	}
	else
	{
		startTask(MoveBeltToReadyBall);
	}


	clearTimer(T3);
	//bool ballReleased = false;

	int ballReleased = 0;
	int ballLoaded = 0;

	int baseLineSensor = SensorValue[LineBallLoaded];

	while(ballReleased == 0 && ballLoaded == 0 && time1[T3] < 4000)
	{
		ballReleased = SensorValue[BallReleased];
		ballLoaded = SensorValue[BallLoaded] + ((baseLineSensor - SensorValue[LineBallLoaded]) > lineSensorOffset)? 1 : 0;
	}

	SensorValue[Led1] = false;

	if (ballReleased > 0)
	{

		wait1Msec(150);

		//ballReleased = true;
	}


	//if (SensorValue[BallLoaded] > 0)
	//{
	//	BallLoaded = true;
	//}

	startTask(CloseDispenser);

	lastLaunchTime = nPgmTime;

	if(time1[T3] >= 4000)
	{
		startTask(LauncherStop);
	}
	else if (ballReleased == 1)
	{
		ballLoaded = 0;
		while(ballLoaded == 0 && time1[T3] < 4000)
		{
			ballLoaded = SensorValue[BallLoaded] + ((baseLineSensor - SensorValue[LineBallLoaded]) > lineSensorOffset)? 1 : 0;
		}
	}

	if (SensorValue[BallLoaded] == 1 || (baseLineSensor - SensorValue[LineBallLoaded]) > lineSensorOffset || ballLoaded == 1)
	{
		wait1Msec(450);
		//wait1Msec(400);

		if (LauncherRange == Near || LauncherRange == Middle)
		{
			startTask(LauncherUp_Mid_Global);
			//startTask(LauncherUp_Mid);
		}
		else if (LauncherRange == LongMid || LauncherRange == Autonomous)
		{
			startTask(LauncherUp_LongMid_Global);
		}
		else
		{
			startTask(LauncherUp);
		}
		/*else if (LauncherRange == Middle)
		{
		startTask(LauncherUp_Mid);
		}*/
		/*else if (LauncherRange == LongMid)
		{
		startTask(LauncherUp_LongMid);
		}*/
		//else if (LauncherRange == Longest)
		//{
		//	startTask(LauncherUp_Longest);
		//}

		//wait1Msec(200);
		//startTask(LauncherStop);
	}
	else
	{
		startTask(LauncherStop);
	}


}

task MoveBeltToReadyBall()
{// T4
	//motor[Belt] = 60;

	int beltPower = 110;
	beltPower = AdjustPowerUsingBatteryLevel(beltPower);

	motor[Belt] = beltPower;
	//motor[Belt

	clearTimer(T4);
	while(time1[T4] < 1000)
	{
	}

	motor[Belt] = 0;

}

task MoveBeltToReadyFirstBall()
{// T4

	// move backward to aligh balls


	// move backward to aligh balls
	int beltPower = 110;
	beltPower = AdjustPowerUsingBatteryLevel(beltPower);
	motor[Belt] = -beltPower;

	wait1Msec(200);
	motor[Belt] = 0;

	beltPower = 110;
	beltPower = AdjustPowerUsingBatteryLevel(beltPower);

	motor[Belt] = beltPower;

	clearTimer(T4);
	while(time1[T4] < 1300)
	{
	}

	motor[Belt] = 0;

}
