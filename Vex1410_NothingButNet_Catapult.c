#pragma config(Sensor, in1,    ExternalBatteryValue, sensorAnalog)
#pragma config(Sensor, in2,    LauncherPosition, sensorPotentiometer)
#pragma config(Sensor, dgtl3,  BallLoaded,     sensorTouch)
#pragma config(Motor,  port1,           Belt,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port4,           Launcher1,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           Launcher2,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           Launcher3,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           Launcher4,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          BallDispenser, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task LauncherUp();
task LauncherStop();
task LauncherDown();
task LaunchBall();
task StopBelt();
task DispenseBall();
task CloseDispenser();

void StopOrReverseBelt();

task LauncherUp_Short()
{
	// 1 rubber band and short
	int power = -70;
	motor[Launcher1] = power;
	motor[Launcher2] = power;
	motor[Launcher3] = power;
	motor[Launcher4] = power;
	//motor[Launcher5] = power;
	//motor[Launcher6] = power;

	wait1Msec(1);

	//power = -30;
	//motor[Launcher1] = power;
	//motor[Launcher2] = power;
	//motor[Launcher3] = power;
	//motor[Launcher4] = power;
	//motor[Launcher5] = power;
	//motor[Launcher6] = power;

	//wait1Msec(20);

	startTask(LauncherStop);

}

task launchBall_Old()
{
	int power = 70;
	motor[Launcher1] = power;
	motor[Launcher2] = power;
	motor[Launcher3] = power;
	motor[Launcher4] = power;
	//motor[Launcher5] = power;
	//motor[Launcher6] = power;

	wait1Msec(200);

	power = 60;
	motor[Launcher1] = power;
	motor[Launcher2] = power;
	motor[Launcher3] = power;
	motor[Launcher4] = power;
	//motor[Launcher5] = power;
	//motor[Launcher6] = power;


	wait1Msec(1000);


	power = 0;
	motor[Launcher1] = power;
	motor[Launcher2] = power;
	motor[Launcher3] = power;
	motor[Launcher4] = power;
	//motor[Launcher5] = power;
	//motor[Launcher6] = power;


	wait1Msec(5);


	power = -100;
	motor[Launcher1] = power;
	motor[Launcher2] = power;
	motor[Launcher3] = power;
	motor[Launcher4] = power;
	//motor[Launcher5] = power;
	//motor[Launcher6] = power;

	wait1Msec(5);


	startTask(LauncherStop);

}


int AdjustPowerUsingBatteryLevel(int originalPower)
{
	float batteryLevel = nImmediateBatteryLevel;
	float batteryOffset =	7000 / batteryLevel;
	int adjustedPower = originalPower * batteryOffset;
	//  writeDebugStreamLine("(AjustBattery) BatterLevel: %d - OriginalPower: %d - WantedPower: %d", AdjustBatteryLevel, OriginalPower, WantedPower);
	return adjustedPower;
}

int AdjustPowerUsingExternalBatteryLevel(int originalPower)
{
	float batteryLevel = SensorValue[ExternalBatteryValue] * 3.57;

	float batteryOffset =	7000 / batteryLevel;
	int adjustedPower = originalPower * batteryOffset;
	//  writeDebugStreamLine("(AjustBattery) BatterLevel: %d - OriginalPower: %d - WantedPower: %d", AdjustBatteryLevel, OriginalPower, WantedPower);
	return adjustedPower;
}

task LauncherUp()
{
	if (false)
	{
		int power = -100;
		motor[Launcher1] = power;
		motor[Launcher2] = power;
		motor[Launcher3] = power;
		motor[Launcher4] = power;
		//motor[Launcher5] = power;
		//motor[Launcher6] = power;

		wait1Msec(50);

		startTask(LauncherStop);
	}
	else
	{ // 1 rubber band and short
		int originalPower = 84;

		int primaryPower = AdjustPowerUsingBatteryLevel(originalPower) * -1;
		int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower) * -1;
		writeDebugStreamLine("LauncherUp) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

		motor[Launcher1] = externalPower;
		motor[Launcher2] = externalPower;
		motor[Launcher3] = primaryPower;
		motor[Launcher4] = primaryPower;
		//motor[Launcher5] = power;
		//motor[Launcher6] = power;

		wait1Msec(150);


		startTask(LauncherStop);

	}
}

task LauncherStop()
{
	int power = 0;
	motor[Launcher1] = power;
	motor[Launcher2] = power;
	motor[Launcher3] = power;
	motor[Launcher4] = power;
	//motor[Launcher5] = power;
	//motor[Launcher6] = power;
}


task LauncherDown()
{// T3
	//int power = 70; // perfect but strong

	int originalPower = 57;
	int primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
	int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
	writeDebugStreamLine("LauncherUp) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	motor[Launcher4] = primaryPower;
	//motor[Launcher5] = power;
	//motor[Launcher6] = power;

	wait1Msec(300);

	originalPower = 18;		
	primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
	externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
	writeDebugStreamLine("LauncherUp) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

	motor[Launcher1] = externalPower;
	motor[Launcher2] = externalPower;
	motor[Launcher3] = primaryPower;
	motor[Launcher4] = primaryPower;
	//motor[Launcher5] = power;
	//motor[Launcher6] = power;

	clearTimer(T3);
	while(SensorValue[BallLoaded] == 0 && time1[T3] < 2000)
	{
	}
	if(time1[T3] >= 2000)
	{
		startTask(LauncherStop);
	}
	else
	{
		wait1Msec(500);
		startTask(LauncherUp);
	}
}

task LaunchBall()
{
	while(true)
	{
		//int launcherPosition = SensorValue[LauncherPosition]; 
		//writeDebugStreamLine("LaunchBall) launcherPosition :%d", launcherPosition);

		int originalPower = 70;
		int primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
		int externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
		writeDebugStreamLine("LauncherUp) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

		motor[Launcher1] = externalPower;
		motor[Launcher2] = externalPower;
		motor[Launcher3] = primaryPower;
		motor[Launcher4] = primaryPower;
		//motor[Launcher5] = power;
		//motor[Launcher6] = power;

		clearTimer(T3);
		while(SensorValue[LauncherPosition] > 1300 && time1[T3] < 1000)
		{
		}
		
		originalPower = 18;
		primaryPower = AdjustPowerUsingBatteryLevel(originalPower);
		externalPower = AdjustPowerUsingExternalBatteryLevel(originalPower);
		writeDebugStreamLine("LauncherUp) primaryPower:%d,  externalPower: %d", primaryPower, externalPower);

		motor[Launcher1] = externalPower;
		motor[Launcher2] = externalPower;
		motor[Launcher3] = primaryPower;
		motor[Launcher4] = primaryPower;
		//motor[Launcher5] = power;
		//motor[Launcher6] = power;

		clearTimer(T3);
		while(SensorValue[BallLoaded] == 0 && time1[T3] < 2000)
		{
		}
		if(time1[T3] >= 2000)
		{
			startTask(LauncherStop);

		}
		else
		{
			wait1Msec(500);
			startTask(LauncherUp);

			wait1Msec(150);
			startTask(LauncherStop);

		}
		wait1Msec(300);
	}
}

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{
		wait1Msec(50);

		int btn5u = vexRT[Btn5U]; // start belt
		int btn5d = vexRT[Btn5D]; // start belt

		int btn6u = vexRT[Btn6U]; // start belt
		int btn6d = vexRT[Btn6D]; // stop belt

		//int btn7u = vexRT[Btn7U]; // Fast Launcher
		//int btn7d = vexRT[Btn7D]; // Fast Launcher


		// Launcher Speed
		int btn8u = vexRT[Btn8U]; // Fast Launcher
		int btn8d = vexRT[Btn8D]; // Slow Launcher
		int btn8l = vexRT[Btn8L]; // Slow Launcher
		int btn8r = vexRT[Btn8R]; // Slow Launcher

		if (btn8u == 1)
		{
			stopTask(LauncherDown);

			startTask(LauncherUp);

		}
		else if (btn8d == 1)
		{

			stopTask(LauncherUp);

			startTask(LauncherDown);
		}
		else if (btn8l == 1)
		{
			startTask(LaunchBall);
		}
		else if (btn8r == 1)
		{
			stopTask(LauncherUp);
			stopTask(LauncherDown);
			stopTask(LaunchBall);
			startTask(LauncherStop);
		}
		else if (btn6u == 1)
		{
			motor[Belt] = 80;
		}
		else if (btn6d == 1)
		{
			//motor[Belt] = 0;

			StopOrReverseBelt();
		}
		else if (btn5u == 1)
		{

			startTask(DispenseBall);
			//motor[BallDispenser] = -40;
			//wait1Msec(100);
			//motor[BallDispenser] = 0;
		}
		else if (btn5d == 1)
		{
			motor[BallDispenser] = 40;
			wait1Msec(100);
			motor[BallDispenser] = 0;
		}
	}
}

void StopOrReverseBelt()
{

	wait1Msec(200);
	int power = motor[Belt];

	if (power != 0)
	{
		startTask(StopBelt);
	}
	else
	{
		motor[Belt] = -40;
		wait1Msec(150);
	}
}

task StopBelt()
{
	int power = 0;
	motor[Belt] = power;
}

task DispenseBall()
{
	motor[Belt] = 0;
	wait1Msec(100);

	motor[Belt] = -80;
	wait1Msec(100);
	motor[Belt] = 0;

	wait1Msec(50);

	motor[BallDispenser] = 55;
	wait1Msec(300);
	motor[BallDispenser] = 0;

	motor[Belt] = 80;

	startTask(CloseDispenser);

	wait1Msec(1600);
	motor[Belt] = 0;
}


task CloseDispenser()
{// T3
	clearTimer(T2);
	while(SensorValue[BallLoaded] == 0 && time1[T2] < 3000)
	{
	}
	motor[BallDispenser] = -55;
	wait1Msec(300);
	motor[BallDispenser] = 0;
}
